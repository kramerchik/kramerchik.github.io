<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30f60bbc3d74819272e28b8b672a3bf126e6db24784177caebfe7ee7295886974a71923f778523dd382f786577361fc437fb605a1b58b9f280051bc16c0489c16330df5a0672e5f0f82d36ae602227d925e499be0318ee3db8edd827a3dda6c99162f4d7c155c8ad3aefc91e7d28d2d376ca2457463d3a6518e45ce1cdb4e26e44de64be4ad8dbab1f25064e14ad4c9924cab09bd15b82a9e48462bafd0f81495b7e4e824944bbcf174428abe0ab4c0875e3e4c97a7e9673d57af54be1abbacba4f241f50911ec2205bc6ced6552ed74a9a6eaec8b5baf1961fc8e439991c6890e90f46742192c060a091abdbb455b96c6feb5bbdd34945ab7c0c160cbee100b39e60a7308b2efcd037ba5804c24786cef3d393267cc307689478a7c5893151546b9491908f78bb2b9deea88bf3d851f47f8519870a2bd3168960ac99f63af3d96b6a4505d0ce99e64b61da20378afca28e1e70fb85769e6239dd56ccf157a057b66002e738c10f1567cff223d471ceb552df08c987b904f299f8ae246b716a3428c03b1c4b78a778d63a4f494c7829e47abb8e03ccfd9ccd8ca7119600e4cd83649a72639d04334740f058373814c892e4a0ee31880295289e12eebd04f5d3a2d6b2192c10a44b8ac0a1546f6d289b0da6ff32c53cc6c188315334d55ce04b3251dea53f07c62bcf5c91def6997d2c5baba498a81921ada5aa05f27c5b8b227f317ebf6f5f1d617802ec1198c479287f131fc95b00783afaa5561abb3481be5d6727d736d9f304db6397b8477ecce363111b8f831d2d69c52c1a0c204a4dea688e6c14fbb63549cbf73de4757e9fdf2ea021846299c8a7b4a9f4c8361f54027e734db7efb43ef122488da23d4727713aa2a5c6bb7d05fab199971817abc085d5f4c085d2b291a760afe26a4486b313c7d512750aea0d1367ab251edf4d1648a5ad8b1545977b541b2d9d19ea9aed9c953a6818b44fba0dc924027e48e7aea1dbb842f2c87eaa55c48eb7d90c54b2df807b7ffe746c4c7a87b3afeeede5022942114f4aa61b6f3edf90308228cb0d6fc5d62046bc070705b943dbd515eae45eae1bc98903175f4e9a54693b5eb936670eee72b6b155390c48b4385f9fce1754ff1b154bad6c8d5e607c137961644febb465d95d4dab6a76089be136f041222923a6721b6e58ef3e3ee6d116a26b32bb4448adfa434ba3247ae8e0a8d9519f45b5a83e8d5ce559c53cd6d8d32211c9bdbdf24dc3290d62a057a5753970aa7432b59a6404945bbe604baa5f7c44eb2faafe6f9bc98be34d8c7874516b0054def524a3d8884b3f2c788dae530b8cc43dbc961fa9a33a1eb227f9887fe624cc21d2e1c616e2da7f03d4d0153ff727d8306874ed639c55c5615acd58840e515d14235953d0a83ecc7ec97645be433d55a64c390dfe6e2370faea660e70abe3c535920bfe1f24c3a68bb8b71b9cc41584f8da405d0822c794fbc33593fd527fa35080251a33be8a92d92702e9995c93b6463b4252e6de986db1c31be911cd703538a5fa424d8df0d46dfcb8a03ed49dd9e52f8c74c7615de7895aa11f3fe0539e16a79d36132e0caa82a261f38c6bc08abe37ab7b5e3ccb629e991e710c6b0646722db74c46a4c4da1a84ddfcc17ed302651fe54aad7bfcc51dd197b01960a4dba327217682c04cd9df993ece71c867de43c782ebca1f468848c60357074a46cf4aa3fbfacf690c285f3402e052083d2973e82f11a8e4c82f3465f2e74be648e374966cc272906b57bf9767719d811c7e6cb7dc072a47b0f941c638637d6e8425de10735ce50a5d3bba3aab61aab78f4f3d06f0c4b06bbedbf45d1e7152d20e66eaef98114c35c920524c384f1cf16610a3e7a93e6e4651b9bdd307b376b1111a43340558d893764e6147e966ca9cb404007d733fab1a0783929803e7dcc514dc42d24926b259cc5eec92f475707fcfd025681df1fe37764d0250019544d83a1b2e01771c68295d037d0f63b1ca5b459196b7f7aa013cbfb166bd45960da24c946ffe4a4e3dfa9122df0c44fe9db53abda61f3462e0de40a8ab02f042fe4e92076c7908e0e8716b2adfb5bdb9cf5220bc70be29e3eab861d9ebbe861f2eec82fedd6081e01d01b08d93be2f46d6d59e001fef07a516c9bf558f70455df019f6f3338eeef34e27737b8811305838f86795e208fe1294ab8434421839b287acb1e52390b67163bf401818ff8b6c29d642af4c19d9ecaa42b90fab5ad18a7f012b5873db365890f72f10f2206c41d8cd4beb302f79aff6ba5e5dfdf54d77b65cb722858491d2ee48f14528ed1b6334a07e766edb5729cf127634d6659ff4374a265653cdcdba37515bb49fc9197b558d475306521a085d1a661b87713a43dd427cc0ff6579a58745cfc8d4e319dcec67d5a5645656145fe24a28524362e9883db9fa2e7edc637dce21a030a92a5324dfaf91a88e069f0eaac5f5418fa9c7511fa4e0ea56aa857d7e8467ea4aaa0de6f27b3225463cd7c8e629e581c66bf84205467e7386cf7491ac5d00ae63c80eaa690eb8c5132c55ed0c6f288a2ed0aeb136ceec22c66205479a32647b25341ddbdfc0cb553af2b1e8177162952a4bb5d41b5c2c32d09eb3b9b7424b6d62a94a9cc52c1e0d0dbd552ee8119e84f6ea81616a1cedbe12bcaa9e8c3c2bab073b14f884d0ab8659b4b02c3b576069fa50c0b31126eef56abb3cb6c81fff29a65c74651eee62c344972870f841470b7d1fbfb65a5d5b403523cd808fb7f9174984bbe7f26491af2c70deedd891e937c958253d1c5fdc60df09864ad6712d0513f5c7e80bf4d35fbebfd8610005e1645f73e4f4d18b774df1a9113fb0421e0290f6abb059455efe8590626d8be5394810339dc9a4ec21366e016c1af13ec34f11a04358b3f13701258358219fae0014d5e47397ba7098e830ea4ba8c5063f18385009a491ce5a90148e29efcabc63f7dcb7bacaa7d5d49baac9f8e4158f68af3b4b16fc0a8291a36f2884c233226ac5bb415b25221b340822dfabfe521f5dc9f0f920ef8569493868e0a0d046b893c6b4a52de729a9589decd5193659f9d9688c89508fc8bc681bc0c744e22f0e39c1f55e2552359871c83332be50d91b2e50602ee9794783aad85af540228ce72a44d9e0a17dfe2b56e2f0fb0935f829b6e228778b24bc9bdda5f1e9be7bd92bf49cc080e1cdf490ab41afb1ac44c3aa54de4860243e660cf1dd75b7214ed9b97739898a0c0a4f25f7aedf3541e1e4a43c156fd020d9c3301f6147b1a1c9109f2ed5a97c7382e5b5a0169f2827cb46113b37e3f9cf6e56ac9b933b581072771f462c93d1fac349426b892bce14e57824259e07c846652941bcccf173d0aa1dcb3a0e380e230172b7150608a525243ad87411b6e17d3402a7667e37a73f9163cd0b1261f17988868c62a49132e6dafce6a3198b25600baeebf6f6fe28b8bbcabe7dfd2d06da58724745b81a34322f1f48872ed7914443ffa20c99d6529aa3592eed5968e6831aba80f8d94fd86aa4b107943c7ce3162749016f322398968ef98658ea7e13c0946670080cb31cef579d6ff4cd6a3d869e445e4487be30b1a75316937d9a3573a03e648e0ea05c8c5d432ceae7eacfe2d51887e3575cfcf3e62c83182cd719a134e2e501c575dc03e254d64bc6a7a321f56809eee8cafb9158581c97b1ebe6acba4ee73520a466f68c5d0859aa4e12b7fdd70a0af7ef8e09d1eb25122cec37328449cea49e2cbd4d5cb9f5258f0869bd57c70e78ba9aac2c4adaf5126d41355248b100acd6a719c7d2636131200f26e7f31c0f93ce41de3c6511a57c4c83463f1c91a99c148a0d994cd2911276690c5f79d37abf18e214620eaa0a0d332f734ffa126ba31a10e1b7578ae44f14c42288e4549d2806685d89147b4d11a9856ac4ffe83182d79d892d6d819f851c698de0800ad32c6e09261e5255801cd91dde00a0a600d8388b634dab8d57581d9068eceb4a55b077501c5c1a5d75321c4e69020d2b9ee52a705bc7709884742d97881d7029e1dc9f3a037e1de2ec245ce42f04db8c411a44ed56bde1094c99c5f655f48da405333df01980bf330659143291de55d25879bcdcf0710abc5621080ef023e6657e53fb99af514f35f885a6c597cb6895c7656d8487097b5bebffff83fe5b4d699a8b583fbac5f6cb867a49a48b86bf22e46bec085350b45aa074412f8f47f58f18f18eca84b80f8f325a9721d564af35132da32d4482382d8ed35a87cc5aa26b515ea633f0f82fbf3c406dc5b10b8b91383b6655639eaa1ca5a752a8688ac10c7ccc70cdfbb5b8acf6f719ffab5a70ad88ff85a000475164d4d1648156c2d10609f6996bff0d63705e907413def219e38f3a5b0f673937bf6d22171ad6e7110d28c069e83b46664ec5b9487f9d5c2285ad5080aadb9dbd4dcb223c4d0714e437a4673bbdd2aa27889302b17c307956ce9b62f2442e57391eac626a2837c035ee4d21cb6368134630dd1906e2a6661ffd4c6a3ee56984dc019161bd9fd1bed133255321d4cd8c904ecfcdb7391bbb0fc7452ce10ef6cbacee1f199e72ec81e20660968a2b324c493cbd4b3dbe228cf3948c28ca77378b9c69394f17fdfc05d82761b34b537ad5fad3fb7a69296d1d00ead2d8a683fec6fdc580ee438777c169e2d9b15e29d27f6cd5645625e7fd1974eadce630a3dc8bb19f43935d861c3ea6c3a1def802faa5e86788493385de49e2bdd6c5a8f81a7e276c7f6c26d6bd89dc14364ae829da0f794e77f0f2cf9020b4247ff0cc33dfc9574fe2043f9e482fb26afde96cd4436ccf3605845cb90ab5fde913f79de69d3e0000cf931e5fb1458557977331ae3eaa54c0a4ec4904b94c2c5c0ebf8eca00be32e942d6baa0ee1d138e8c36b611746ff3d24f17ef3accc548f2c9a85dceec291ff24b3c95928ef44a896a6df61b65400bcb08183f300a8391857482ce1a8b2555a6898d0ddb975e7f6813c9d138951e01323c1535b5fd3cc226f43f0c56f8ff50a2ed369fe41e5965ad334016f02ed65ba3e8d8ceb3df2a40ccdfbe03ab7d1639e233d35729ae4234195ce7a023198563c4314001f13800eb940c1cf947bd36c2ef4f5d55a0825bb921a77478d07815cfa57120aa2ff95614c98093ca67bba20c812d179955996b9191fa9c26ca4f68192ab30815fef15095bf870b34126fcb96c2032105a2a153f08c06e6a44cc117c8765b7fcb86747bd4ed9e2d6f031cccd0a3a1bf07113bf5f9da7f46e649735fd199dfe1577052b5d6f3efae1920dab454d01bb6fedeb3892c6e24d379022c365e883e7656e38bbbd735be11d80ebae0c1e759b58e259f2cb9fb8fc5759ad3fefa8fecf62425c1f35bd5316a28be408cc5f0096e56cd39d43027a4918a918e7762f65e4e1e64af60046e46c897bec0c8a898933ee3d83c1f580728e7b483653ccd8c143aa4f04f737c0718e5e077c5a97a96a49a9d5194757ea526d463d8fe8fa8958d0145ec3a6555e1d97f23aed290708072e1d7db9d2822c5e7ac3d646428419c63727e99854cc93e845a6eaca5bdba74985205653cdbcf7faf7c4eb4b6909135f1d862f3cfdb480dc621b1494f0784fb9f9c2118aa8a0532cd43c812d2c6d5e4554cee3616c2b23047b3e7a8d42ffcedbb9bc9255a19b6e1e281e7012f8efaa8d2e298a4d3c5e57dffc8b9aaf508631fb278490e99161773ff8a3983fb3652950d1cc50b82a668786bf1028f2ae3bbffcbc4cc9f7717b4cfe04cf9638fa7def988931269f14c60632eaf2cb1b16a1a060bbb75a0ede64a264e2c65ace6f879f8c2546ea91df8d021188f707a10f6edc494058a52c12283bb68fad3c2ccb330ee7484ba013e778b88834499ed37bc624462e2e6745566f9d978e5b94cf2e84c73e4db1a5b2d186dd902042efe47f5d747fbc51447cec5f20993f00db3227aba7d449e4a4da65e2aebd0ae95450d0e2d37d30e63f3e4c8aab45481594aad801eca00b34c7f90c4d79a13da497cc79d522ceaf10b4e0d7b0d17ebe9f9aaa97a5db59a2d3d1992ea5d6cb6f19a9e7914df7b1c5832b23c06694041b39d299296a3fb050964b20f5613ac4a7377211ce6c7d40a43db140f0faee45be750e3d220fab1e099b73b0b931d3e869139b0a0959726eb27c0b4dea5966594b733b83ac82d7c3bbd2264c260d089bc0861dfbf2fa96053f8a6f6f5921ae2b5c5d13cefad9c91b56c563a4744913719ef8ddeb4081ec9f6a706c2f15cc7eb693b69578e0c77ce724b679e3dfbca01116ccde3ac3cd6e78a4e365c621a0151fd2d9795267660284be0c0c35fa490880a11d02897fc6b1140bb1dcd3fae6cbf7a52381edcecac5cd18d22d354f77a5a5c889bc7c8e435d74a7ec1e6b3900ad1db217b13fdaa1fd1a44ad16bd36f84031f85044df90b5e24cbdc452fc1eb98921ba8180142e0457790f6ba5c8f4072842269c7db223e303156858acf08afe92a50528c395ad1c54111114d1cf3fb780922750aba0a6cd9c681906b488b743c95d903a9942eeb801cbf404387d8e6f5753779e2018b0f80224dc30d26a3bae1905266e7dd024b5b0a2487669d176e3768f9137f189bb3cfe5edfad4eed3b235a77bfcdf003e75b88da8c96ae9d76667b49ae76fc863f2f226f12c99c5d54d4ec27c9c2e7c1834102aa72b12e54926841ba41698417087fc130708e44a79f7cc3200a38291ff44ecfa6d997efd1c810e591c7d631a84439325b2612f312daa073e51254e453eafb84aae1f1a547232f448a7e95cfd29c67d027edc72cbbfe4d26c1e47646d18f189d693c353df21e63098d4eff1fa545f5d8e0adf79ad85824f56cb2f6911762239ef95f2e93fa32b5b2f1404ae32c828985fb4b7a4df0fd1e65912b3e23e4ad040fa961400935c7cecf93516a6300321ff21c6fa190041a72e1accbd61985d9247d3def9e57831b2cc203affcfb972a7a21cff14eca31bb9f7eda3e2bb48ed1ab19951c530d00c2d32a2f01b3da95af36a20026b0c81c34c6ee6bb786ec06d844415c00378c4795b5839f3e69c749a67bb510092d411e83d35ea9040ff60ad86a36b8e25dbbea48f0ec26dd8fed74477068f2e9e6116d89be57fbd6456029099ae0ae86fa21a3a14ff7b95b155ff24a1bbc736fab629e0c1b276e3cf8ef139b50f681963021de1708f2fa284a4acfa71ca518a70b88df2cadf63a0bd8d5ebdcb13336828df588ba55e36ad06749e8d7ac9ac183834b2e42f59d6480393a76d0c64ac3cfdc68e28fbd50827698a404dc8cd93873f51432e756cb8c718a197db928debfd7cdd62408f3982a583a73a7a8aadacb7e1c6105dd30e350801bf840849567703938b76ad777f7964ed483b9b5747d7b0202e1a11fe66593531a1ef7995c19fa343b43b578ff3d689e93778fc7c994f91faf4f04b0eaef01bb69332ff4d888d6f6ab92a33d0db24e8de684b522a9fe0299fc52c03564b702b547139d3e5c0b78880539a06c5ae669d543a7049f5d8cebbb499e654bad7e4bd1e4865e6011027f4c72d44655a950047f37ad9b03212e7c0147d44fb18e57606125acfacda9cd25e76647bab0c32000c5ecb9a71e6cf029af47e8bbe61e8450cf4e1a26fd4072bdff6b0916d4af52c44587875a239a0c47c845e9a523e3594e0cefdff4f0cb35bc9a769c4ae3098976cb8dabbe3f52c0c4a14423556418adaeee849f2b260b1459f3ab0f55ac09b447e108563943dca6a44e5768a82654f4fcd51248ff6c30ab887a122a908a1f30f53fc02c6e7bc17bae602cc8a5af551a8f7a81d57aa6c85892c0006332ba166f9d2bbb66345b08b174accf8dc31fe92378b18dad2797221fb7e1ca72c7a06d6fe8e9b0f4c987e3a35981bbaa8118a31b2e082141a2087b07fceb2f056e8fc20bf6abb5834931a329662edf9a0be7f7e4eb14d98141b0b35af42f88fa8e314c38c125bdf9f33574698fd66c50d41d48262668bd804a248e6522b4d396d6c94a47e3f7cd9eb973fc002709b545b267afe4c82365417787e7c1fb7389e1d4faddccc507fc588f76ce88d1f6c05b55e65ad1b1406c38ff1fe6ddce81857afe2df40196d121452898b9b1af024c6e7c24d339cd8516b5a4dd4b9e45214572df9bdbec9617b10b09ca9baec2a8b3615a5b8fe293db8a6cd3b11547390b5b1a5c0f8dba5a55548f6d543023c5cfdc93288ae8e061cb25ff3d835edba4d8e6d46246ad97dd887846cbd1cacb1b904d558f697ee76cae7c123daebd66f43e81c193100865af0b8a158d1bc0b8b327212fb553011e2a6ea91ff0b80fa86e898dd89e2b1c8ce398d76e4a2ed6a9f4fbd45fbe5478f8330f2ec79845d6816cfe173c7439ff693aeaf611209558a294541f2c6911f34fa810969b054236d7aa3cc58753b85c8f629b4d10325785c64259cbdf40ee072646b7b8916c26bee97d3d266e447062b51083b6c2aee4a69d136c5b7cc2199ae1997c1c4ec0e4c03e75dd940a08cb859e8b541c4f20e23e13cca747d4b1fdf43c85cd3b0527049b75e383f169efeae3521408b1cb20505d68a0c038d0c1dc0d96e2246615ed2038ea567eb054d30984ff8304d705f53fcbd35dd36010b128774675bb8f312a86025ef05ad35319fb7b0b70815b013df23c7606f43feae700983a8ec48a8d829449e6fddc1c04bf3ccd51ca423654c526c72a2c6646efcbf08d5a98c44a965708643b128da0de000aa94e1f5f9e4676311a946a24002d5382d6f64ee51c3d2f17e9a696380d4d2f13d71a4adfd8f28e2b727392fa47fa6b2d0088d198ce8ea7219d1fd0b7f2c1674ad18c6e443dc6ac85327f36da19ebeedd8569012b9526821cc05bce037b9fab4526bc0f3749c5c4ca33ed7864251d847a4c9474296d884c25209ae4d6f0870958d2c41657e9d084a1213c09fb7aef61a9d609806ea79c2be031f02e42eea6992f26d4b465d04fa49033babffd41f433333eada7181f8dd6da218963cabe7d244ef85a696d8a560da4edbca3adc5a70712a35ee1c15420fb120e13867047c04bc69bb86aa11e0a226de4aded7a2223fd65efabcfc541336e49620e94d38280772c4a97ae6deba63e533bbdc27a2834236046a59ee06584ba1d33cffd89c7d217f41c1bf920c5e2c54f3859688ff06ff5d5eea9a9492e73f9a4037e1e59d44dc8d9f052d34f1981cd125e1e7f884045c6810e23c5f5e5940d20ef9e54d44fb7bfe1ef7c7398b58250f7e06751b6f155d5d34a8b211cc7a90281f380eea8aa88f23a179c47f9848ee741bfa478d0d91cd1739abcf5b1e8d06bf0bf47523c1412a755b92ebf2fa1cb51c84458cb0f695481016491d9ba8393c36e0fa5d4ad23d40be47a978242abc379c2163690d2ef6d08bdc8336f125482428d9378b226d3170749088d56a6de680c9cd69f737b52ac8058fe2f7f73ededb068c2297b08e5f65a4c239efb66c5962e26b7844e1abf08a323859f84c9e4190127adf8dc11e7430dd977c6e36e386411a3b676b0c5c2e9f949ff06524adf189c6555936081d5f45d3ffcb0ce5f0c3798ccd952dd8461c9e11a319ee76835de6c428b42d9dcb13844ebdd251437e4780712d21c7c7bc0c076d6da1fa5dd1ac8a95f8590c5ac2df82c4655bd645eb7b8193c85a612214a517c617969525ec3b3c3b2544bb774ad22c2c82de32a183a36bfdb9020b48b256913bd1dff39583145c05e8d4e40a23068d39bc5e9c6958f2e9a771ee2776a1e22452b6f1eb2ec5c66e27c8113bc05e989f97b646cb41ea1ddde1e94501b995d11dbad44191ab378919ab973ac721d186b8201160dc3f00e58a7737d9c87518161b1123dfff6badb2cd1180363f7dfe23394d49c7d1b02f1ae6226b7434ef7c755f5f3be27cd9b2edff902cc62864a89fcb58aa96464a4d64926c240c066c804b44757bcfe0b33e997c0d17392f6c7b72ff01fbb9264cb40d106c775e76f7cc9a5337e5bfdd476ff8318a4cdbb1b83510a4607f42544b08cd3e8061e0f74df53198f54db765965d10235deecff61af2e8fdbe66d716ba2fd66ec0cf75c8b075054fa149aed89196af05343386431673eead571094ab93beb907f8be11b3bafb6151d8f9548d93738722d023ebf36f0862cf0bdd867c044210c1041887f5929325e165b02af21b5a0551ad612283014231ef1b0ca86cf6ef7c53cee835a527cc525838d23467ccdf97306b552edf7d7ce81b61b19b0d78136bb7e4a685051d0e9863dba7b75bf8ca25e29864c655d09416726450ffb03b76daa6b1fec06bdfd529656ded23a33c944fd4ecd057c91ee333bf734bf25298a329d31a44ccc8c91a10803f598aab7ca40eb476325bd1ca174c98e5cd8e85cff9af093c54e3aca8f38729fae6860bfc74439ceb14e6b0ff3a3eb18e22f79b879f26e2b8db140b5df21232d8cd8b54281feacd9bb3514f1a2c406bd45cf65f9a856b7c06a42a51be513f72755cfd1bfb818da9823b6a7bd6fa28a75cbd5d8cbdb822773cc73dad4cb55d7e9726b9ace5373217ebaf90fb532473e428c90ae017615b3bd62aa609b6f3b5fb41972873f0a019fd0806e52f79e7a1c2ef4f329a30c3d3be8980c88932d3d75266becc7b05a7ff8e0054421ecfc467f23ac832c9869411315e0a07e8d7bad0db5100f3a243795d7ccc2b09781172c0c987ec58b16fce055776a81f9dfe9c2ba21b035e5a971e66a17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
