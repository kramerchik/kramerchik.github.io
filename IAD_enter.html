<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a426808901f872c8c0b0928350f834f9b8851e0ce6ec68091bcadf353b5235099e30fd30dceeed8e0f7f7437ad25c66668d58f94669b2dbef95f47ce639649430c31223c2d5fbe17ffb018dda27261c77f5d57c4148a9f5ebaca67efd62d38b91be1d0f5f4111436cda9ab2df9eb179f0b7e5ab4419c5ad71ff331930fcc8d22942aee25c415415fdbeada7dbfff170bf9a5667bba79de9a13d179517d70f91cc7428b6d9de96da636a74994193bbd72e303d982900ea5d9a980524f3b4238b80a2c7ad823bce7bafa5ec5370f14dff8a4ca87bf14e30a2483bd0772e55a0ebe6378962b9819b8b6e4e6a44025cd3713c8d9eb5798b520aca2ec184e7fdd03474227fe592c4734805fbf7f0096f43f59ece9e6956611ca3dd3ffc547decd357c2361f5d4ac2750e3d86140bff542d60b8585206bcc4b5e801774ce03bba49a0f06fc9892a5e2975cc7a55297be2b59aa48b884c511f33331797e261f111c405ba7312e312b8ca0de6aa7682062cc7006dcfbc3bd527a1d441ed912e7d063f91ef809113c68a0183c21d575e2240dba9f9d7d82c68922f66007c4651fa1908e8305d88ecc652b82a0ef85b181c5571e0e3fc29b4f0dd5f966d6d9d901ef1e1331c9c3c42c98ff6a51ab5391acf1f544ca2cd26d91ee40d5204bbd181298235f8fe8c7f783226c747ba9dd90b43d05cfdacda909856e7d284071854b8eb972f77d4f5f3e519e46bab03742452bcb6554154712d30ffbdf5cd0c1d2065905b3585505cc988463c58d48a232abbfc5c00a3bd49003f6b28ca6c087c141850c16b3870c5aec693ea4f83b31a8ff48207de2276a9235b3e193f3c5359c1cec2c8c9264c0a2738010ea25f111657c6f2358301d98f5207ef0b7107ad8fc7aef953dbd72ed2ccd12edf2eb7809fdd808c45cf69925057917c806934ef9f520d98d1b4493a7e614bb536201b8f1a527c4e2650f9f81d2a0090ee9db0491c47d38f4298a428dbb1b9af0503c9f6141a8759f3075dfe4f84af25b348c8644e412cfc4bfb710a4e318ccb80f7fa9679297c104ac332a6775dda1fec16c640b43210f38f179206a0db8fa2bea768e3a46d9befc92133257187968097738629660ca945d43ab629ffdcb1ee9153037c5d21c9cfe162498c1b41ebc98ffdb1c9660cb9e084264f4cb662c87700e368d6176fae1bbc0fbdcf725a60352789689112fafa38103ec3f8ce088d019c4e50c8fad8bb61eeb14eedacae85c12a8d15215c35295b7b5c2a1e5744c0d32f120437eb7cc1e75684d223398dd600c3eeaf0dd03c1f46f2b237f71b0c3278a887fc9d5c718e96f084244212eb1f52e1d1342a43a2249bf286e5e69122feb51f405652dee3cfdb9412db1fdbc79302989dce9a8a851d5509a8e86501d8c95af350ac6fb89ae9998714a58705d7eaf3e3714c2b7e196c7c43fc99462444e1efccfb06ca254266ca2f2e33b157df6d9ddfefb214e62f0971d767535234663d98cb777c350a5864165d1d82b35dab8a9acaf6c27ebc1be1ef4f7c62675a1088ad68843f947a7c24d2cb44f5c85b435016133841c635366adb8ff3e539f1b65436acb31d57f39baecbedbc872d76d2965ebd0ff2bad02b509d72a1d60d001b399e6900451f5b929f9a2041a1862b34893a6a6e30e28ce5f02e4190f22f076b55e1d335e175fd18b29e349b00af588a84f3a2f19afba35f23f526f4ad42ab0f2acf13442893abcd7070b135ecb04de70f4464b330cf42b6d2e89b02dae5ac3323266a22c5a6ba4498a55d11428112bc63d622598858a41729b41a9cba4d24e5ae5a3a78334aa861dddc23f034ff33721ba590f3491f4c86d17ac1b2efeaa71fc5aba14d0e3f16f34ec40d8ead943f4f6824c5298112a5837954ce09cee221bd5496413622434c4b3150c1aa7f0f8ca9fb1d1f8ef1fbe1cc7df6330e34639db783bde09935f87860e677a08b60aeca17b140a4d1caa6c626c0723f566ea66680ef4cd4bd1209367bbcb497db87ce24a7a5c68aff4780f686e21df95629d84a44e15c65eaf214521bdec71c3e1fc70e7e2a4022562d8a70c61943fc97a428f09a1db9fe9fd37d6a93883df954b47dd585cb63bb0dc741dcf71ae7462c44c12124fe5a4209d3b8923d887c552d172451882b9a8e1f672b5ff075021ea7ff95dd6bc08738c4ab9c68030ed6e8df5b248d4c3afd0f3b4d3a0437a71eeff38d2a661f3e24b7af344f880920274ca8743f2fb1a6f5d057f39288d3543ce636773319c3d2f5dca7255adafd0d2e563db9f0cebc345ca1e4db2ba778bbef6402720515a23894f2509721d76af6461dadea30648a37fa659a923356adff8ea59b039ce84d27c48d577262f5c4b45128c14a28e1a195caf5ec5ac4e935abbea86242dbde579cd76055dff0157336b60c2295d93bbf45bad75b09614e507a3c2f573c7c545a3a9e74499df266fd805ab5d9fa69f93cad38c04204498f16c2a4af868c3a3e8edb3348f7b9784feb4866961395b4c7b765165456ebe4ee786ea1e82bb6986bee26f8843e88a3639b450f257d77b2db48be326ed7c274fc3a864665bf469a9bac05142e379a7bc97f55d212b78d1bb561374572e861f92de6784c66bc91893890e70e844cc9ac9f36eabff2acf3434ab6def0c7ce22db16ebff063e3c56a183b9fadab2ffce221a6653c4fb8a0129aac37fba646f88377ddc451fecbe45db84e4daffcd9e4264fb6a213a3cb1b663c3dbee04c8d52272ae207bb281a37d1ebb81a9a49b0de8639b5caa91d24afff5206634151a7abadbbae481691ba885a3a40f33348887c11a928875005300dad11f752067d9b4aaca0c6d7d74ce10748b362b8ead2707d68e4b74136d4a452cce3d4b6c6da3109b6e739f70e5b6da28956d691c6c0abd32d04764968acbe9c2ee00ecb9c459ed8c0f86b12ec2c3644f2e9459e1054923aafc3e2d59418e43b55e1cb4c495c7090323a37e8e032a3c96b0bcb2265fb9a46ea30ea1f513506e2ba316f1905ccfb74bc7bbd93a9eddadc61c26ab6d8b75f623ba3552f54a6dc2e617f630f486daa3011ea8c1a17b9e8ae5013e1321f0c9345c5c29374f7826a23e57d91b7cad40b1aa649d304a680ef31cbb24b0455ff5bd97e001703570c93d9e97a3558f272f6eee7e424fbd064fc4623108f485e90a93624e58a20eeb4487d9c2b579c1e4f6ac560bc141b79d43de384b7df6cb689ce30d3afd0f482587053781660b8686ba4e11e169fc7272e2f338d78017f2c5a902a2130bc7607ac067705631853acf1c3301eba0d125c1e91cd422a51aee8e4918ef5cadc9dc0baa0eff06751d52a65fe8dd7686748ced0d08b64c06a6cd1bf34e3d6c845159ad57b7c4da271c7df9fd33b351a0224c05abd75ab166900eb95ee295e6e07b80f025c8f7092105ce7a2467fb4b9fd82626ee6ece746de17dc13fc3df408dc7f2b8beb19248426aaa866092eeddc8bcdc5cf8dfea6f99e103e46c27141fc056248636cbb80e0d1e589e17f80f65a24d45ebcccbbbdd9bd0c481b5a03c1918654ba611bfe9d7f816f251dce95f48d9df50cf1e06ad7885d14ea6f3bea3d0debb04fd966ea5c22188a30c2545cfd55943c0e6fac8f2ee5283a8c59ae9486882afa48c6133b9c9b08f7af5b99441d46f33c95c320f731fdc10e61e05fb8f90081a7245128559b6a432f4592b3a5e3f189bf6d555f8319c7d6754e29449ea47e8449155931d2873ae8ec8f0917d593918a2acc254e45dfb6562b3de9aa161325096567858ebe123b551342262f1eead09ad916e6b98f8d5b1926e37f52a75a46888dc432a891c7b31c27cefbd033e15c0ceb1d02bbf53cd28169c2c44bd604e07b6349e57a7cc4f3767b87c77fe5772993a247b767a2c6c258c490a221367ac41974e00d7b7d31ed18b9e145a3232f15daaf30c77bb302b09f7873a5a5d351c3037bbc424af5c44d6d96fb136f204c799f9fd183c5224feb5bd3ff6df8a77e5cca396a863ff8195597d5e314994f5d70ba372ffc7b28d5e7f1f7bff26c72ac9d8cf925e3d483e556976592bd37c4fe0d07de6f17e0f76cb94941ff289a2602eb67ee72ff167414b93c4659fe1db23d4acb5de286829dddc87ea117df397f4aff37146f92fe80e204a7e617a9654e89d6aa2ce04a48e7f4d12e68d2b158ad54e590f7d52cd7d5a061c2c30f6c1ecbc14308bed2c1fcd15f0ddaa373ebf8a8e9752bc33a384580564c5cfe96b6602a8206e2c6931bc252f7c26fa56799c69f82b03e554243ab0d07873aff234da562a91dc2ff541f58d763fb1d5660fc99e4799a17ed58e9d324fb4b4163605aa79d31d11956328ce54e42e7cb2e50b6a62729983de90b2cbb529735fe0dc5d25b9cac9368152bb10467c01a5383fd5a76daa9c9b487bed0dc7a8244f0fc2dea03f8d139636af8026accc39c909a852dca494fb942967c08746a30bf655957a009ce536930cadc42bde9470fc949947f8a9c36e57ad5f24763ff94fe10504b4dd059bee828a8ccabeeeeb9efa4312f74ee4670582b9235291faf3729b74c027a7e7c482fcccc97ab8fa11992d0433423cf1b342dbf0d7ff94c234313c30035a28672228bf19cb54385a4f1f8526211ef0fca3d8794cd7b765c95947da855c5691c181ac866783bce29294b7fb3ae10eb46ca734a2008d657b3d56e90e81a959c57e36fddf113a2fd12ef6a6939ef19622d401ca663e82d81152be2329a909c538cf6382177ec1893ebca7803443ccd3a201ac612ed29f10f56d98b825ebce5dbab57153536b80f58bbeefa4a533b3c3f6e6690d686e39116f6ed988a52ff5bdf288aaea10cd452d758caf90ae14e97bd0b28c85598247ea99906f2c725bba50bdd3ff618bb8a394fe23c28e7370f89f09a0384138ddbc1097ee768fe65b4d6aeffc5410b08f01b11da9c750ab306e12e99cd2cb25294f9f3d655b79f16cce42b1b8a6e15693dda2857405966bc4cd24829778f40a10e6115a71a8cc9fea4ca4829c882f1074ec3e57720895e2f76f885225e75b9ed35de163ee15a3ca0944e697b4a2bb8f8ae80f41d4a621db061520540ac13d1ace198b88fefb5afa88f9772b909bbdb603434600de63129d109bd4f5edbfb6dafd3d528596d42f2a8ebec52c0328ab9b03396f62c6e0fd82eaf5f522e38ea49980e2f71cb44878bc05fc7a895d06b31e5d04806a7eb26a12a87009251906934a2139b043cbd45acccaeaefb71e88a8b2c065ef398d1bb959b25b2dd2504b70d69110f850b263ab37a32c9fe8a14d2d6bcb9010cba003afbea089025450907c4c9bab4fcabedab64104eebc716b2ef92fde9318e21390457872f77dce0f9b55df20d5aa9dad0b23613f511c3af9867df67d53b489b5fa8dbace8f69cf50e89ba3507755026ba5366601123952dd6b62defdf89a4b1598fa2b2fc43a978dacf35fc24f78bbaf226d61b127cc13592392e9c14ea6211105485cec744e68ce440a8083ababae82f2c55134a320bcf5a8ce336c94f5402c018ff45c026308f8fc6b5972e9666e4793d5b574a367dc7e59a0a9bfa28e2cfae84fabe67ac41dde219ba56e3b42acf43dbb9eaf78f0098092967b82099662e90305f21093bd547a9bf68603c5f2b583de0bf8704a76009195021ff6f0862303ad0c73417faf9f575df14d7ea6380cdfef2225208ea7770372868ed0fe4eca48e6e6f662f1e75851e29f5bd6f0ae308d68facbf05712a0b1d9a740937d031cf96c63c395379c487032c7e45c9d836d88bc8fb94a7396e8dc1bb3dc8c6b7d62369cce5a4185ed70ce11df31bbe0388ed78e4cfae496acd6860b710df67bdac517b53fb3f4d9db535e80d2c7032adcfbf7aec6212146392636c73ad2cd4806a49e55ef1004097eed6b9eb2066e7dc70e4ef43cc047f7495a3f18e51165afeb810019b0621412079865dccaf21f5aa448a2ed586e5f822fe31641ce35acc8730aefd9bedc820784fe43f6a0a8f931ea107fffd274277eb0a26bfcf9bb2f9e0ae5b1fa12979be933cf2883a7c574fec83ae5c85574b07cf36cc957fd875c73968d32267fb75a56a8d408dc62681d7b097e53ddf41f023d72ce0ba923f34f6b02181b87a49eaabd2a2a74306004634774985d9d09f867377537910b8277aa703cd093ee72b1a0a507de562b06b0cb9c477a00504627b27fd7ba8ac146f9683bd4f93a684ae3907506e6aa5000519c70d4bef1e605f8fcb88709368d26fb986256d736e1a751a10e9318ca67058a48a4eea6b3d1558a877f4fce03ec0e6e8ae1c41b6ea82fac1c3301d49e54036427d4c5d8ad04de63476f8cd1e79fa4459e1f27934196acd9feef899ccfdc71d6fb28e689f9eb288497db30e237c2a7822364027f02fa7774641ae1d0eac16b9897f1672622950cf102ad2b796d918205bff57c62124361c2d467ac8095fc0e224a7b8f59e7ab4d6158cf67b4282c8ac7071120f5b62d48d04e8a3f3cc479384a19418e3aec40b3858c3414ece09cab16293dc9a5e7f979cff47d5d0e2cdef1386819fd307a59d4d325da586de19f8de1688c58127615627a24c4d92bd1ff74fc448b5d195b417ab7a9f48a9d94540cf2d7b0b9bbc70e528c94645f5f24479faac29c0270dc1f7d0fa5bed53c823dc8878b0b540e2f2331f466b19d282135dc070565b5c717fc863f273ff764326b1e5c79726713511621264d4ee5a1e29ce59b1fe6c40d2d5d53d6dcd09fda916a0667ca6c6ece70ea891b06deccff227397b3cff810c20f7363cb90617aa211ae77eb78c1255042caccc3ea69188d192ea9cd69dd962c958c9081523c9afe6bfb72ead2a5080d5b77be738c93047d170231d8d6aed46cad65a2f1097ab1ab1a79b28287e23b749568226602625f52e3431ffda260c32161c10f103b8e0eb9a9bd4808ee893eac10cfef37598c2a1098020098a7ca14896c2970621dd5420f41afbf42cdf591d343d874f4d0dfdb6e5b6fc784923a0674ccb8cd21c5422e1045cddf5a939adc4447c454b355fe0b343f020c1124545c67286c49fcda09e1967bd1bca66de233f1eaaf3129f8c2acb4787291a05cd2d0a384bd4419fc8d0e47b89a837b5ffa23432e9c3ce8b255df78f298a3d0073c9b09b86f8f41a8f9ad71fdd56da0b14164e938b60c2e12870b256ad9e582fa5ec9ddfe159436f48083ffe1ede08033078149a73fbdabc7a81ca0ee63dc17161096eec61aa34943c789349ece0d9277a74ce4ecc464ff3764dc6be572ac59989730ffcd31d47c5441cccd0d140240af70c65a738c0c37ab23c9b03fafce1209762cd506322530f3a0c5825632d61e5acfa5abf24058033caf4ede26af88a48514132b222f4451bd10288a2dcad5e9a3120ad850b68bbf665753a6df2558e7b2a7de925db04172d3b5da3c6628be5bda5674800b395367ea5dc2b23b42059389deb7b4e2989270522bd8c1136a5da34d0f2748cf738598dcf6d66d9f54115318d9c6c7d69a20a53f4b7e3148d136f999b7faac2ccda4aa3f17c7ce4f65b85e9a88f6451abeda0c53482ee9168c9390c4ecc2a0ca2f0025122a08e8c8dabeddab7fff8ad316743cbcf044bbdd558c209bea3648f996fae3f7f61cbeed7120ec35d96508d436423027ca929ad5430921a3f9008a7266a81f4ccc96373cf5ac456265063a7e8872f4ac7e5e8d7e5c08e715d07d602afd1a1311f36b531637a627f860dc57bcc3c3565208d0aef11a0f395c618b63ebf53a7cfad591ec1f035261fa09d2517ed2c40ea27ce5007c9cb54bc15b040696dccf8b68cac7dda4b8ea2a14e97c61bc692903bb0f2cc4c16ccb1c9d83cadbf165b0863ad3598d1ce146e666af0c26cac8c55c05a3b3079ccdd501dd05c8243f65ed2f38865f499d11008b9423a539e01969ec6255d1ab6723c58df7e1e9378b40d232e73e045c2054ecbe60fa03ba5af7a39353e1d380e5cabc0463125f3b31898f7a1685ba107d3ec511d252ff926d342e2955b4a1d7bbd5e10f04738e44439474e7f6269f985583042bcea632d48d34bf0df11af6d10ef772fbaa38cdc45be1a67eea9a758e8100af3a9e5b4050e79177eb63781a088e9220d5785b56c4077e9bd0e98c553d29be25da8a7f925615d5dbd89d235aa0739d0ff5472deee060639cc2bfb8ddb5276c5929fdd1e646bde43817e54e43f7cab5cda4feeefddb71e204a1f3e427c3fe222da8d38f638fd2e5e5509c4206a758f11383225302dd97874140eac0d667d03c105c9ebb606d10fed5a8ecac9889e4091ac41555d65146b22839d5656795c6c08ec7b205fb3886bb0a07a546ca8b90aaec21de4583cd4ed263171b04e5b8bafd0ad8e9c54f6f544bf809549384ca6cf8a271bacab9081b744ae3200d6531606249b867f2d04e82e9cc60e2bf066de4c554d925a334e5d12fa7616e7f0183c770479fa82827e838f2c0c85509a12336091d2d16cc287d454502270dd25ec2fb96e171f383448456155743580ae270140192968971b95a11b13e5e4031273663be397a199e3d1b35dc6b816cd40e5636f0722bc6377757b4a4c615aad071765529c69a7adcfc22a295722444378ea5cfe5cc8ef007ab4b1ef595819823ae16412ea617c5f2d0d9c5408c88cca024a20810f1f5eea5ec9335338931ac468f57f7f898c64a820e96e055399eb91ce2350c05ce85e27390aee3e56be14742e5ab20d8be3f148d8ebfa03e452ce7912f8a9570383be47e67c82b0cc48fb9f2cfe2e77b11055f6d12a55cb3bd4d9fdde77e981a3080f3cfea8e7925ad02c6b26abe86bf3edcdb6ab742b9a3a62e398434a80088f07aca33dc6499cca311b951c2d5b2a4aaad94ec690bc2a943fec2fb4a3d96d5c215a0d4ffa545e564ff27b8b1d2394908947e83954203f8e187b1605033cf5214167fbebf338a147908d1708d3ec0e384305626798cd858c2b60785a5696cb30db18a5d3e3536c24b302eceab499d01d96ac0a78d0390a724a7515f2c6943c93d6cb3ed0fc9eda97a11d0421f2e1daa40b3b968e513625053f808348280848460efc5dd4431d09dfd5dd2d73487d10a345135987057ff63b3fd85ef1e91be9f34c5fda512261cffde17b19920fa4367770a69ce92bec542e6a09b52ba623dd1bb6274dc34acb5a34e3e0a6c97d46e30ac166b147f6314d0c1f277b451ea7bf9771d9e1ff836fcd4157a1bdee5baa93a4d9b063874e78aa7da53e85533353f98872ee7747020913928e5ab6bc4b357bc044e7bc92e047f2ac0f340d0adf9d248d22b7d1a5ffd72875b439ab3577c4cf23a342897c4ea9d563f2bc96a01e504db882887f25684f857822d2542b58844c10552214ad5f33ba8f32c65898437ed4033b5f5661f14169714e53a992924cb1df6348183ff6dfb74e3def8500a3013533f17d303dff00490b58963194103dc2763b5c9902c4790c81b0ca70b5a58cd3e4fa5c1dc81206056feb2c6d0a3332023f754d04c707d4d141b602bb70f965b179e0b4769150e5ac9536924c2de542423e3d45cd8ad0761ebd8f65ca85e0e3e604beac13fb2a3708aed0a66e3f410a415487e74e2882ad8b41b10f00c4337236baf6e94fdaa074162d36da5540e70b9539c8c06ca772ce6c01744c597c4b0ae343f6ba0d498ddb7258889bc6fd680f319f1a3e4775773038fffc6fcfe58bb214db13ddaec88e2d0b6b1e88139e6d11bab96656013b1d8d0c0d194a25bc5251b9d932f43d0d8b3873d261f91732a9d61b3c3619a007cbe510aad7aa9a7f94f941d9cc6c94cdbf99d60a695e8a4188bdda44c76af3638d0dc9584bbdf9bff4734d90a2a4ca644d0db82090cf26b57fb1f7d7e98436b2143c34c71172419d138c1b9a4bbe8faf28872a3e368758c903fd23f4b51cfa35f7c3502deede4bfb987b9974391beaab99871c9f3e39deb18918625f347e4c3d7fcac9cd63293c01cb16b6bb0ff3347c383155b2dc053595d55c27bbf5f2dfac5cfa05278deb517f2638229908cd24425a6ab3957242000d6e1adb78579ceb903749a267be9393a69a9f343a9a9c2646d22f9da18475119a7fdf301bca6118a9aed1f3d55554c34cf203d394445b9008cb0ec4205ab0214f6fb2000686349273a2852669b5a90f682bee72962ad2c10fdad8009ec7a6f6c40571b82b5de9ab298afb8445e8489c8da044ffdde4a630678c96d1e36ae3dae141c029c27d51e15f0af8b838603da7f0cf4827f354ccf825b2f5f7d9d05e2d4a2d07eece6a279ba56aed341734ad03c22a561531c641880e9c03082616b1cf42c80acd555a3bb8d44db9a0b9afc4e09f632907bb1df60e0eddad556924e1e0390a4625bd32f465400450ab148f71501c572611ceebae8fbb4dd92ad4036a78d51300569c79ef92adf5be15977757e571d1072e29bfd3d3644aba99b23fd492ce60e9360d869ddbed023c2518a941fe512f370282d2e29d0e4b41f9ac490b3a02bb71fc60dda3e0f4e53c809aa8da54972f0a02ae8e279d3bb4e59fc79803756d8362ee8c859b5392789ce9deaf35513ec534db01710fd1f8404ee4972fea8451f7996605006a72158bc7f0b68f733d698c13241353c1369182ca6b96aa39e5c7b1d58557b380e11e0a06a05ab91a4109acf6bb049687843490993800ee7d98b06afacdf8cd5ff85a4c27beefb92ef576080c59695da8b54ff295fdec3dd9318b150992f59c32800a1f746623","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
