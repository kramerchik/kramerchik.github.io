<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"512a25aae269b65bfd06ae1ddf78740b465b27d2a26715dbcc6648e3e6cff37003fba5200dab7f8d28d5c7884973176f01ca7b94a81c5f818703dee7e2ea7c90ec4159a3290289d63d8aaea231c4bed470412ca9ef6e6ad307cd3faeb879c5149578c3d18d04db30e2935bf5156ad9f8be59f818135276df576dcc158cdbf4792d067121f670044a6a554fccbb1e44d4b36f4bb8215efec43ba1e83c44febc8a61524eb417478bd073e4898e0f58e70d44d768a08909cb17f1fdeee85d8df9a2c13cfd7f8d4b1f0cd4b8fa9edba76f3cafc687f42342ec1013504468b3edc24e6db4a5c4202ddb90936fd9642c91624ef61e3bb3589825ac10b9217df010849d139434b5f51686229b13d5aa208380731fa13f507bf6742fdeacef8ce42cbba38b1480a340498193f81b40557f5c922ffc65638ea6088c6a731979249325160d425883416e612900ce2366b6baf44b42136df7517c1b91bdbfe35073f68db48d3662d7fa00f6a133ce73ed91e8326b4e7c16559b83f998b9ae170af43af04481c5bc465f2c80af4ee5bc513aba2c12327e395cf1f5ede036665e3bc774d0e9d102e504657226bc15341891b30db9556f894c7c2ce0e3fc27a074e01cbc4730bf8dd1f01a68c8973df673bb6035229950178794ae74560fd92b582c9414a1ef20f57bafb332e7dd3a409b9f0135a5a4c11d0432a0184e73f684e5c7787882bf0a881205efd30a54c936e3c261943b688674b347b0aa1168ef1653d6a943565776168d1c7fced3ac0b38c2ebadf43d1956b646690833b5d6d1a50dc4eca9ddb76d967973c1333c4d89a4b4ce46ec968ee12162a8896d3f7bb6967836db182470e9c858b113ffd0793a88ada84227e886307ea025b709f8c863f1da3abbd3dcae5ec59ab19c585b91f9dbb9f7a918e7e233741229f105750ecc0a71f45c9d8d7c925451c3f72fef671e40b338efca3e9b0c8b44242ca470721f11c8f7e214ca7d9d851f1eb93ac7653fd393bbbfc0a5112cdedf6deccec7f432265a5cac07b94da6c3550fbd2accb6eda07815981ea4439917c24ab8421aeae848eb83c7273a5a972e0064c5faa905ecfa1b73658f86a96c6177761c8271c94d0124f52e8046ca1b480b0c9887d1332cb478efa99305fa749b0987a6b524f6ddc890605c90dddcc3281e792eb7143214e020476837274c41017771933a921a83101ff6073483bf2a22ecf38017db85e5a77fca580a42bcc0b45c3027435f489b651ca9d8687d93b1cd388d2931ed160073593737a37dd72eaa85bb51645ba73e77aaa5cc3260b15a0b472d369e561d5edcc78e1aacfc0ca969f4db1cd6fb173733cc515f08dc798c3bb41def896d1d47366586f16f58bdc31da6a723fb0be64f743e0ad2c5e5e87ded70bb87a602fd5a3abadc977ba0d08d9cfa4369a1d8b41e3855407fef0a8bb768b03109369058c6cad53392513c966819b9e606860de4bbb189156e59b086d15bba6c9bc3508e15ef5aab5f9d8265ac818dd89d6c7d50afce07ea8457e6dc8f91b25311392e5c7cafe4dcb397603db433b23f8668f215ae6bc2dabaf8f7f3c9d4a97d39804c72ca46d3cf3d96ec14970c2f90517111e6b737a708c7de3db6675eb0e93dcef0f051e8ce28d1716c54aac14c61a2b7cd7bf60df25afbd216b41df75518330b3a6a733091ee4dbd0613848344f8192cd0a37fd1d40e1d949701c3395a1ffa38e42fcaaadf97055904304d7e8a4cd03c0ee553daa1eabde5f413a9e28a149a105a1793513a7bc817a4a54c6b39f202c6a5f7dfef49cd3b5f18178ef569f4914b9f598274ba9131361959487328924ea7741d2c13a65b4cec5998abe1a1c718ad7ff74d312ba72134722fe4ac9f3ca355d0c865863ba11f99b548232257c6bd4346fa3473497c3f90fdc0f52685e89d0b684d85c94400222c76f5a79eb29252a9c0a0de78cfffff2f3755e1f9b12d4d73e9e5a0bd687122e1c4db36ac4e416a84efb7c35afe5f21fffd32cb01183761902f9be32ff11b7141c4ac49469e04c1783c5d254a4ed0a956220aba479971317dfae271dfdda543562b5191b3f7de87e959291a36edda254a648fc4ebb01b45a697eb97078a27f70de0226900bf0ac4a711ca0d7d3fcea728c64d005a1e652c36e9a2c69e66d7b124cf8853a843b1c235b629f254112585049a26701c2b407742c0c209394b992f21d85820a2ce251772ba5429c4af398f36eb17ede34b37d6c08c82d6a31cd06b5165d4491ef2ab7fbd246e67d3fac6580a9d7b5afe1382bbdd248dbe0c73da69ce69b605ae6f74412c8fa8235e9aa25ec32ec11cf7792d534f16fe3c54aff58e269532da36f69b4ff6f8db4e4bd651b7ed5345ddc1fc174ae4673d6419fb8e6d17a42048526ebdabe524be2a45755c17909bc50480d84633d320cc8b8b03e99d9db5f0449db991824b43aa91c97684611c702d6cceba720f0a47cd7c9024b784b642d0631e0ef952d0ee2f81405b9cb9bcad5b4c59094e7f1b834a7b32584e720d2f27a0d095abcf3744695a7f49a40ebe6bfe46af96ddb728d700125107a34507944255e26d26e1c26ac0bb14e6195cba48026708411cd109374e9030a9e6e61678d041798ca34060f98d8d5d455e1ab24507ca93f07e402037907d19a98fc111f358fe801c8f28dde94cbb54834abc9ac5f5c60beb15790f56b854c7a0b8fc827c62c48350ee7488b561c48e274fc64a849c1ff857ac709f0c5efb51e6f8819296fa9a3d95c162368057450309b0338a799e77901216f982e69687f510c783cfc2c69914e0fbda7104627416d49563860b432cfb00a3c8ffb112369bf26d657d111ca5ffff8699f4132df9edda5b33036ab7287b797ee90773908fd5388cc13accbd065f01eef27a4905dce3f01ea259525e8c802fba741b59ca723f652bf3c66cf83b36b33a1dadfff9a4aba635ea495d56d3ac31121ebad14fd8dc73604113b1fac86688c741da1a683f564bb37f71345cb1f55e2f885feabcf8aadc744ce3b641923b73da73bb5f578a1f524612f230b4664b56a30ded76f1918d7008f51ad1b4089c27a5701c16b43b20b44c33cf8c5606c8670a3a71454de3ef1aae3dd8b28b0da8883741dd10ac9d2ccc11e98127639e68b4521d2c4af5253e3d8a90723db2e96c859ad4e699a0a235eca5b1fbd119439d8fc74945523944be131116b104ba5ed2044d7a5a6371778603e5eff7c0575256b1dce44cc471f1ffb5eca9499d2c0244afd2629bb08a820cf2f120cbc0bccfae9a9beb0e5cde29c36b36ed5ff6703b9c2bee4fcdd0c62800c39ef405b8bc81542c3bef605e1814ccd414559f422b950129025030c75f6b84449a3c2352f40a8c3276298ac9e5da35e44f459e958acf2f2e0a4e0c8a4f66f87eba23a6449002077d2c43a4dc9067330e81abe08d5f860b92d3926173c9e2b7d243a22fb4dccc4263a6274f65fccd01b20c75a98d063babf2aca2ff2edc446174ede6a200691d231c3aac0eb9e920889e6474ae6cd755f446e82c1df370f8453ae1344dcca7ae573210ccdbc42584140a19be16c1472875ea990fd7572bf3b7777f51f5e081a7e2ef145040de73d35ef3fc50e951fb553b1a00bcb25837c0aade0bf8b0003bdc226798cc09eb749cafc6f0c96ca817be443ba285cdc7849d05e06af8a38dc176619710e23743e96c12d7e479fbf9e86063511ec71ee8eaec02e7791ec6d231acbfc05473d64f355b3d0afb84a43b443cd0fdec9f686c68b6dfe8baa311cd353990d531eb9592925df5054a03c05297262d3e65bc02473fe272468175ea0f9be7566c008cc5a3ffd27475a83fa0aca5d8bc2cadcc78c910379c0d96c1f66d35a9c6a1fbcbd1b3217f699631d6a90c2e2121c31b6641f14bb14ec222e50b382efef4b3ef266191284ab52c3a9bf29bae4bb704c8e462773a3a217fefacc4f9eac9a3d61cab97c3ba9804ca0f66acb2deb2bd74a8c0f34d8b7dec658c3178b836f5ad69e5cf281c1e2468ef139aced3f6d30fac74e686d04bd54fe73703f9111d2c1f80b65d90ef3be0c66de9578089346c75f9d92c2e6a6f0d1434c8392d5f45397c84300386fd633c886e82e5e322b3e8cc8be9bea617dcc1bc5813a9de256889e91d3879152fca49e1e711d2fb48f6a77b6b795a6dd02ea5e768ab350388a2e89f72908e3b9a27c4ee05b6824e6af14ebe0b115b2e929b3f9e196436d317b527a7dfd72621a3c8e1bdc9dfbb6a1115f27bb0d133f3033b2672c63c5e979e765604701ebc5c1b13bfc6cbcdbfae6473e4bdf4da99779978d3cbb2022d02e94860794aea37e83c2aa294f3c7895ce271e36c7c852042bfb91131f0e3e47281200577e6f5fde71026f010fe72daf491b2c74beddb8afed46d2c534134ff6076af82f769f74a9bb69574c114b320614607bf6433db1b915bf69d2197367879a878e9e15529f1e64a1947b9ad4adb70252a951448fff6d01dbd8ef566b0755555ac20e7138dd2fd48df67299696b86f69defe6727b4de4e5cd701702e34ac285b435b1c10ffb4ea87dae9cfe2a4565a5a2211e2a18fed610ed300247a7a117f0a9af7bef6d9bd5c53e0fe90cfbaa20374226f4666094b4eb51fda214703b6bdbd6097f4235081d92e88af723d68a230051ffc536c7d3f78d58468f0c9184f6e9cf1cbfd99a6608014a4d462a92fdcf564cac220ceea41266586f6c829a352f0e2a059518d366df7628407151ad48e17dcdae71e1ba3d5b99791aeef5f0557eeec0d23640fb199ad3225f1a84f255e8b6ef9345fd2692d8fbcec2643815f98a8dedc149c9000f1f79e3ea78ae8ba4b5368d17362aa9619b2f7b1ca0b4543eb62deb228f0d72242e219e75123791955cbccd6d127d6977d359f9f9759b0c8682a1fb7bd0e0523ec7722df75f233b63395e202eded6e38cef52fb09f2f7f0eb54f17a6d8e36d0b7cf6d98487cc31c8165d5a4aea7d6623131380c2eaf05279a76f2d460269fa1b62844322ab1f21b46d61e89676749df1183f960d5933016fbc0f66a0c365d74f071f6ea3a1fccab1d7258c15ea2dcfd48844c1f95454912e71e25094eacf899bf0cc2c118df34ddc74a4581a276db089d09cf6ef30669683fa3f945923f09eed788c35222b9b689566dca980fcd28829a6dd3bcd2ab5e514ab2723452d037f1adb28df72e9f790e3ac0b67bc3a6fb2b621c7b81af6b9b42bfcaf7cd6bf70173d8c5dbd1c8dbbf9197088821c1792c2c4081dd0f7a3debe31ab9c9f4d3109f8a0f0025273721d1c4ec194daaab192c5b2ada4e05259a2789699ab514f126483a4b5ed84e5aeba4304c7800014ee2e1f1bb6d5777fb51957182a36855779b2695e5c9bfb6f931a52849a2f8046364afc027ecf4360b880da347647aed6fade61b9e72e2479a412c67feba359252a51c1f3624ce3ce7fe152d8c737520794b2ffd0853ac928a6f4afd3992ae3e53d94dfedaae8b99691ff3ae0e014972eda7e741a80cec76c1c3f22f5f7d73601cc74c745be12b802230278d83efe876b3353cd8b9313dfb2e2ab66bb979bda0f6dda5331dab366e099db058aabbefa629db5d509e803187d61729a06406a5b53e3529c14aeb9ff60a16c8d2e54c920dd64d134e7ede28aaaf28e739df21581cc45a7ad1b28754c1826f390711aa71309b541694952e671f618935efcd4eec7a8a748169366283a243bf2c1d4d8b99a3f2f82430fb3edece92badb3841e26586cbe178866a0e384d46bcc3b4aa119074a5284a48567147874f0cdefe7f5222c2dec7cc6c083e38829654b1f797a13c8e48c92b818c0ef454fcf2d563c1510cee1ac67c6d0a25cec6b503406467569a249585f6483e913f14493f104c36725d62adac6da552ee2d081697e1bee990cc7304f6b3e994f43aeb848d46e661ed7b0266adb481d7b4e8b14de21e81d07f40f6e6bdf3106d3939de01d6c25cde7cf2c54f64419b932115f84ee751e50cbaa6d37482528537afe3c589862455e5da9e879adca97bed0b3d719a5c433ab4d84a161b6e7693b79e4908c8a4054308247fcc2b084408b59aabc7b12996764d6c158aa561a1988bed4f44fc98ba4e7260f6b07483a205fafacef5512cab5b4b31532cd46d89eda9cf2404ec27ef6042f5aed4abaa11fe8d7ae59edf16866cce98897049be65deeb0e61322b339d7038529c4d29c1f7b34f8a55ec2b774184020679f695621117e62c9bb4f674d0e6b5ddfdc564c7cd66a2bd6960b15fb13b4ca2ca5c30b8d33ae084816067cf6a630df971e014b479bfa466ba07e2b2a0726f5fba26ab34b838b95f27bde5824ff8a05b467299bbecda481f12ef8e5dc5c065941a73dfa65c0ab453082c5027d45395c78d6eb5272c7f60e7add7b64996600610e52d5858cbf988378c6c4070ee1accd8b31577b104fb90a7fda00baff2e7e766c29ba268cbacaa509f448ca0193e3755b56f8629a45bf54c81668b4c4f4417873b12bafc47719927118c1f4a75acb097b9f031f4cad7775cb1e052023b8f268496cbb2637a47b0681126c8235a4dc9402d561e8b1a765f6341ab548dab847d60beafec765f5e39917753d12292c6371a48523d47bc017af459f3a3ed23e0273e17effd820a27aea2c918b6944409cdedd974012f90e4bf51c596759abd27b8eb862308d7594de54c996ac253e82796ca7d7557c724b16e4052dea863baac14edac47aaa2c21b94b683f53f04fc5f1169bb3682b12221d5659f87f6a06df3abc324fd6ad8ff97269b69bdd5a6b904e1626e04dc56daa37d55a4f1e0e96a758fb5a4e39c2f8ff3325ed95041871af2d877ad7430aaa7bc3965369696dcd83a9acd96f0b8b4f63ee7fc89f64fea7d52301ed90e7e69519f2e4b9ece7ff740866a39064337693303bb9fea14fe9426c90bc8b7951f1a2bd037cfe59ac8e38066fe4055d8149b9ade65f75bcb64306feb3e4ce4705f4959acd9aab35d768474a40abf2ff45929668c9b5877613ff2a19051937693c21f7b3758319eb927d733da0683f5a6d5055f1ba94ad102106b474eba1eb2545538177f2ef0e6bb6f119005c59b3a4f723a3e4b9dbdf98d8c2abb2a80848deab7edfdb5b429cfbc24e7dab804bb4823b24ecdbd4919d46335ca326bbacf149ed17abe3582fd53e7171ac677629830bf8f81e8761e43eae13531eead2b31095faa26ebb61ce30a909eb68f1fd07bfda97ac70357557d9a99d2477306f6b8c70bef66a41b888739732ac6394797a4b56ba028e80e111c4720c9e7c3184a1de1eb1f78c722429af2097e56b46825cfaa5edfb4c6a381aa9197f2e35218d8208f5c347a9a2065d649f71aa76f51a244d629419ffda34089d45cd548ed20d05b5472cd7aba101a00e37b7728971401ee7f281f648d89555065a164be82cabcf81841252974c546b0e498002760cb989cee2bb49f8512a01961030e734039d2ac74e2f49359eb61a89a6818e723235d6c42f1b5f5e497055cd93995f044eca1c5c7caac23695866a255b88a616cf7ca17068c4daa92311f16cdb87ae33bb049325c966e5b96e9d6df19d5505f78f7449c720d92186c227d76c286f3bd8f6b79a6cb726240f32589008b24525de85c7048f8403bdf0ee87857e45d478415c1a782d830e938e6669afa3e164d15efa00aa0f6e083dcadd7fbdbf8b34245329c16e2b244db55977f2855fc70c7779dc8b67bc6a9e284b6ddd93ca314a428aa0aeaf7145569566ff75d6f6d9093cf80ed18221253f25d4dc4dfb7e1d8c0ac5ec3f307e77b0bcc12b687f0baa4acdbd22d2bfd4274cfd9446b4e25eef638b1eb47aa1f986f7763981634bc9df7081ac91017be7c8538134fcccfe0aa58cb16dd911b04039a74ab5423957431c250ccec7b97525fc09d9a4f8b93da384001bb33ba43eaf717f8a9e9875ad24435eaee3bf8d679d4d95f5938bb1dbc9050e01748e2e4b88cf41fdcf3b4a9ab580736122d2a18b81401c26f9afd0f6d6172a27d13e8a3342c96faf052eca8e8842cacb9db97af0f5d3badd75326351014ffa756980f68a7310a0d3feb27229fe211a7808caebfff1f4addc91f3b1e30cc21188c078c0c395237b2434c2c2a56ba898be2ee99823f17818b38d91e52c82a79b3cdf58463e9c2e1b3d3d10d25caad35a029dbd73e34478133e2a5fa3359c4c3de047a676ee56dd96f7c0a2de5e679450b347a14731f42b8593c0c3ad06cbbd530469ac2da61c88bcab5a71d521f939e2ea0a093f2f77568c37be2a6807f00ac901c20e078082efd997239b1d2cd601f81c2f1d815f7c3ec95c65681966106114cdf67ae9cb4ea1430556c3596fa0254dfb4f574dccd2c124451cab0a7abfcd294d27c11e33995863928d52cc45f4b30c104b87bbf797c94cc0d65749437f5acfa85107cc87c13cb165a9c050fc8653ac29579383db617e8869dffabf497e97c3cb7643d06f9f7209d3c2ac5af3c737493608954efee31e879fef19008af360a5287a37844f8a8a6b9c7a3741dbd4c04fbfff519e3b2128b6b660e30e903e3c82e28e349510134c923e9ae0866687f02c9b20583d25e753f7be4f8b33eef29a1b2b2ae7443b5dd6e975e003e821ef870e585cab0a29be42880d2ccc7200486300fd90b3f315f3e81389e693a8739c7848b864da94222388450bc0a04763e40818e31c3f3ce49a4ea911ac48627372534051fc26e2315ead051cfac9a92950a2503eaa911ebf9e4cd133314e2c13e41aea6cb8a27985ec854d5bc64f3c985ad8e2e073922b69ed9c6234e63e8f99aac48356c71091192e710066dbe08b3fa4e91c59622138be91d7d2489bb23fdff2749341c836c98ae9daaaa8f78968fe059d6cc6f9b70b749bd9202846416c24730df50da32cb93f0b6cfb29425c17194b355585c09547e6bfde1fb62e0656633b5f4486c27530995733c5f646f8b8db263bdc420305731bf1a0f588fdcb2e4c1a689168ed7d8251a5639fb0d96b46c2ce0405bfd08e28ceb57f8b73390472de2ec0c504707f77b05eef5528e3ef821c657b6d9d1807c0d57866ba578fc2510fb44236bdbc64df567016d52f6d7ef5a8cb219c282ae41280b6dff9b90fb234a600906d3a21e518a929b03e04fdc75283da5b7d25415bda7f018fe2669d5476e6fff20109bff5d60ccc3783ec7a5f85ad97e9c421e7957894846da15b8bb562f59990031efa8b3c6cabe1c1a51cba4cbc367754d06dc74536cc4a34d0bda33276186f89ac0bdbfdc4feb8fece5526a5c3dc008c96326cc59adb9b2901f6820e7767c2a914a0fba983b0ff1ea9ffe0167bf3d9c590ab3e8dd4854ac429400b168b364c34db5717d34f19ec17479ce7e47dc777f1265972059d7bd2ec6f7db0efe2d29a2884327e27f306bb7c5f8fd5c704f98750da412d64c7de02bee08412b59726f9262c42bce1a6c424638fe086b35a24fde68ff7d630d4f575dac021a793c0724994469bdf2d24b3ec184cc7738642a2e4927867eeecc2ead086c02e8ef266e3c0482ea89ac5174cd491f21810d944d0476fb588eb997d626914e52c61c4b78b1be3591ef7f2192d23c094c1738b332c89cd9389aeb231be88a66df2ee5f549fd26623683f273b407c83104971394c6d516d292ea3de8f5d9c99e6b9f48265b746008a42715fb0cd151396d4fe9b209485da6c2676a62e52e2536831fb8a4b55117d4ce99e40907700b7c7b09ccae5b8c1a67246a6a3d9a072228080de490380357192e9269514061a7ce995d7ee7ac9f084997f42251828b4eaa94ac7f27b02c38ae6f110c924ad45036f3b4992ed54f39dd6439aad56b50e85055dcba5e025834b19d691f73e1f79d7cd98fca49f64aa83b93fecb651004f8440b0a5468d10c9ce959aca26f78a1260e7b7afd0249f38df7c54dfa9bcb6c8d99f3a539498f86a99a9aab6c573a09d9872038e7bc306737b44139c5e1c31922b3226f2503608b4889858728997753a0d9383e12b27df581d1bf2717c4bae7a27a077f79865a5b277bf3a97b0c4a16936abe905429e3c9314dbe8917e942ffc6540992138073914219ccbdf7b37127b49fbf7c2cff12e048f4e297fb91463ed696c7025bb5c0df809a318d838ab18a2cf725e07c3f64e44e6fd07f5ada4789978102ac2e9b79b6af76c61cc5be14393427adc7b0a649fad260d759a015eacef4569e0febc6216f50b3bb00154bdb9866e6585bb42285283e2aca7f12b43d5e6c24228b6e912f79f07d7e8011d5cc2ab3a97c173c2be17d4d74aa2c49f23128acc0fc6c903780ad4195fff1015940b49df7a0bba563d61715e7f5ff0a75bfc075066ce5975986d28eda40469e90e17ac9267fb65ae51192ca805542b7bb4b865e2bd52b9da8230d02811556a12a50c5bf5aaa187bf78713d5edca3456503df0c96670210657621c5046bf6353f7f379de97be7e797e2ec63f2348d304b4ae3744444255ce10735bd20aac6658081474706fc01b9afb6c81a39420049a223bded99b6fd3ea9e6ab707fb7c2b11014cb609065acceb115eb204d5eab271c92a86098bf5fc4dafd7d35ae7be7fa85fadf008b3a2824d90b350c85f9b8f31167114ce3fbc7cffb68e72527ef43e3000c28601b27de2210e9d7802a33d31b662d0809fa99813dd9e0945ba58bf2e1567b673e645fdd0138491ac545090e0b06f0ccd634e50f507741c85ba4cebf947d0a1c334743","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
