<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6e4f7b8bf155dc8b036a59a48f9010753729be7fad781f2f2a317a88f51894829b2f862257425a8b862faadb02341d45f3125dbb4ef105bf0cfbd6f5edbfd55424b4503d3f69a382028362da812d8cc7b0dc23c906dbb05efc456efebda2b0952da7e944873210b4e82b04226159ad2fc11f7fedee6e428e8a079e94651667300e82a0a7041ee1d1336b2f8b6fcf527c69a0db0d7b647bcc16f7977f1120f138c2c4d8810645364760f7fb39e9a77c1011bc282edf95da23d7c37b6354eb35e0eb916bc6b61b465c02135843261a623ce508b8cf899381a35880577f67934bdf76d7e1bffd69bba911f39b6e119d3a0624c1a387f3a1172a03727b97e954de6e83daa889e7d93801a8e92e43ff33cc60ac3ab70dc270474bf917b9189abadfc2734e985ab4020961602778d393bbca19cf7df57364434acc829df155f776b299e9f3bb64770e651338386473830fee6316b9fc2a094efcc38cea6b51e6130f4be0681cbfba531b182462fea70e262aa75840e52be2dec545c292823cb1b0c3c5a701bc734629220b59e28207599f7ab95096b9fdc10c4d3437b9fff6fd14119c8396af7e7adbe3872b4c210c90a2b82b3108ca7621d486cd6c20c8fe4696c51355219dbfd114f68672e292cf4b44a5e425894191091ff89e8d90077ea4ac07f854ed3f5c538fe1703ca2161523c27e54d4e90f0e67aa1546b340062ac51bbda82771332dda2cdf8cbf905e52e161d011fb7979a1fbda4a1949ea233999f89f706e60951d908c16159b1c6797bc8bad6cc99429bc1fbc1b1530af446a09833cab19ce79ca298ef4c555234ebea00932efb9155e5b1ece67b95f41fb8000cf156762e4a15c878857766a244f145db02b9be065cd551de3f4e5f8d5884de02b231f93d5c195258eada55a8dfc525f48a1e8448e9ff4a14c89d2a4553cbe6e5f33db25283a30e7a9f7deb7ab47da6d311f3ca0d94d832208153bca220572d1bcf38f74d9695aba5028dc8e12fa9fdbd81bbd24d8457c19a4cbc2d6b6664c940058674bf63dd2786afbde5d519cb431714f9cdde6cd892feaf6979c6af0630d900914a711732114ca51ae94eb2afc323010f48083a0e2ac4c151671a3e0bc083e5a7e10b5ef46af720ecf9821fa28abe713a6911057cd784515170de1bbd304f3c8c718ffe3d9c1c03b2308d410b7207f1ccf4393ddc0dc35374606b6f733fe8a16520857420c33bb96c523a12afd36a1bf04353dcef0d5d2da3cc9a40ecfc4fe2593c6edac1a12e88540de8f125b376568033b77a74b04448665247976eec637c37e3fcf3b85c07b8fb60c19fde6b61ce2893ded958cecb63e3ef7d4db3517bf742d28ca8a47ee9bab5c4488a719ebffb66fc08959653edf7d3cfef528ed194b4fd6c9f0d79b40ba398aee8e384ee312e8528d598b436ee22ad9cdfce40ae50f4e372a16e97599698e4d3b998796eb747077d23fb4908f37b449532cd38e149eac8f4a0a8cc7606885fb71557d548fb896a02499d39a668883b22da84852a46e1cce20735937691474f344386df5e606266ef6a87a7eedae1a204bc372f2329c49f097ebf0e55d1fdb997e2ac5a2dcec9c49370c0ddb61b1cf2127498837d3f12e5ded74b137d2ed9448e19c9b18cbcf95137adfe08c8009ed957385792680adc250c59d9f393d8626297de9ea8b260d6e8f5c1841b99f15d31c86d07c6364a52e7ce0fb8087f9b2f676ffd40e15cc492732cee5275783d948d8c86d7c1d6901bbc1f1e15222c43b65814948e9687c47c705f0c5bfb626f9e261a1fda0c970093479ba88bccfa1f2744da0fc08542ce0c7b3697128a8d9cf1c713aa2bb168372794cbf1ab3cdbc99d00febbf83e535c7f2fae4243396e1dafd77f4024add56c57beccf7cae4568573cd0587830faeb002b101fee499f2ecfe200c4946230ac5ce4df5392328f5873967556c409b42bdace2776b0534a7c8b911385b13bb24cba567826d92798a5c7da7ea6defc5258120db63076f733b324ecfa1723ed65d7db0086d162e8afe422c2e2803149ea07c55d0b0115cde6ffaebab3a0be6a43c50ae91471b9f606e9add4d07129e7c6a2c9fd426507b2436be6a14263456460f30085dfd7fe369c3b0985de43639eb9e8e4408718507e55b2cfd4aa28d19ec26645f3d1106ff596b053bab8351bd7a0a1ab2b39c5881c27ce1a139dcacdb360323a0f6816b5a7875f2c97686cf82d166a3f806e8b6da078f6fd64b95b5791926a369a14e92d29880a1794b034545f3dc72b127e37fd31d24697143bf7460649812b1294caa6ccff6237c97570338fec99c61e77ae5d9508830f3d5647bf2a3fa39bbf797c45fec02c4e0ddceb830cec122b0476586be3f98f05f10ab2ce5888daa00883c951ba76d5d17071f0cd8397f0ef69709e78fd4905470167d42a9d49baab23b071c5c5e7f467a0f028771650b314f084417174b7261e302141b4be712eebc78602171f29d4bccca41e3caf5c2787723e3a47c4234bb4be19c0c2670110f5844040371441580b9036d1353639be553a475ee09dbfd9b46c66a483d16fb375ed445bebe4179d6c0efc3d9b6708d0b77f074f15faf82c2ae3185fb8f8e73a600389e8c1bb9871770226c9bd217b4bcb22b22bc20de2241c62114475819805d3c48108096740687ae4f54631284b506c7d7fa533c3cad998dae5ac01fb441e6e9b49aa216dca24eee5219b80d15ac459fe0aea369e610946cd8e08c1d9faec6715417daf3b39e2308ce44b1acf6c52f4b3ad339d05d84babce20c0ad44f8af89988481fafb98971634afc83e98dbc41aefa8ef03ecb18276f8eb1d8c78433567c298f8e229d1b077da3767721533f65ea9d70bd55596e557e753ca5519f0e43ac6b38ff8fe835479c24a07281ec4c7b6f10d8c77f857f9957318c991fccc9d44dad6ed6b9a8f8ae4a371aa1e26702148d44c830038c50632ea83ccef530071b4c36b46b5e486a5aa1d2a3e08717d779de70c51120ae798e5a132cc91f0632e4d11d792e703eee36d49ab42036c87785139a8011c01c81413cb781de42dea05f5b57b75b8641acd5a81f3b1ade19ab2906867bd9ff1c3d6aaa729f3ebccf037a5c9098352b5175385cf458210711746e53cc7e1bf96b554f304e5beb7612f0402bb0ba7894c910519cd06c69ff5a3c30ef60b639d0564ff2057815d0c19acb1dbee6bb7c94ea6ed5da688a26e2b2c769b862c457b45e8406558dccd3c8f9e43bb41a2955d0a0ffb879609afd141a839166df47cadb188afcb0d4fa8526552cc5c33aeef85acf231ed86eb99ae3e225c2d09a253913fb7a405467a2781b07adab663847785d30938f41e3765afbfd2e65773fde475be48e877c51602897c1ead1bb5e89f90e332ed609b4d8143f4ec9480ddd1da2cbb2f1baa9dbb64f97d8ea8f5ee1a7e4cd5397cfaf009a9c09a8ec6082cbe487de0d61a315ac336f0f9a03ce0d98577a98bc0a1e860008f98fe238bf385cb78a171e935fd16bbb452e50cad2914bc2516d57a2dbea212a22a647cf740fa82c0cd03a01fda3c63e71e9b6738d2be35fa08700359d14b1f4a2c0669fa36d0c19f984178ecf1fa287a6ac79693575d7b0959a618f5160c0507b8fbd8cc8b77a6a931d456def5a275186af815e326428f03c039db31b96ffde263dc9f97eba1f082c0ba778d6046a6bd1615330fc51f92b3305e1a6c2541ac8c29f25c8e23e533b7ce6a1a1245ba1767be47244e76140a0e5331669780ba7d0467e00a0a2870f9fa093f978bbd6beb293ee9a234dcd1e6c533a04472ee7a9694acac918e30741b99cff38c3b55ca5221971757cacc67c0f6d9dd585b45dcd9929f07f55b484722d2ce70f9894d0a3de5e273360b0bc7229200499aab900d6b3af2432a16958e0e383abb3fe5911f94d2839013d31816c75e39960d55cbcba8109010675b2a5671b12a8f753ec02e0a952672cb7bdbe51523b1552cc033422c38663da3f0e1ba72faeef042a5d4ae2643c7b197641d14b576b145d2cbd89d3c1a42a4adc0629924d9db78e2854dd0ab490615c70432f53b28e3bac828ac345ae5ef921a3a53793e3cc06d15f0b2b76b82d38cfcac70d3c42281630fa84069befb20561b94cb461ffda24b1f5ea288172cb484fe05c90ca528d4f9f3ea899a1eb7cbe12021fb075caffdd2428225b2dc125da0c6e2c065741181fc3207932a3a9147fb35470a4198b95966b8df59d01a9157e8d26098bea24a6e15f55a1a59defe766ba10bd2f1145ada2a52307fa28114f6fd155dd8d430ace62241a663db0ef75b1f3c0c00424d1a7a644eb7d03a50a9ad0ddc6b9b142a0586eb6be2c437aa16370d975b15e76c26ff18f5cb4e830a93241f37eb045dd0e11c05f66b6593d355bcf7b088e24a26c8db6f2a8be171a69341e38aedcfc43ea4e362481e72334d907c2b4d7ef048137595dad4916ccf4a180e1753fc85f73e01b28a7ee4f3ce03c996e894194cf6463c1fdd1a52a5f2df7373f45372b9ce52d1ea335a7b4803e6ef5d82e0fc0535b3ea86f08bf57fdf2c3f159323a8b0f5d1bb9699acccbb513d867595ee0a2aade52cbf296dceb1d46088936d2e862a2ad1a1afeb65f4eb44de932379080e72cb570611bbe9375d174b8d5bb4a9e3b7759ce3e8f6c158c741540af212d48e68c0020930c511a02ccae60818bea3511d7fd6a7b70cf05cf226256ac6c6f0177eb0cfec6425592be4d9803c0d5de49c3338daf96e3f7ebec5721978c468bda3d8489a66c760732b5000848207a35b9968e4d4feb5739e3a9594f5cd78f4b895c454a42239c88f6dab495a4d995d98fecea62b1e906f00e17231183a40b12bcc8062136df3a4fb079b2d83bdbb4ce70560a08343def9cc7a95d7e3a5ede131dfeecdc5c20e15d528f3cfc6bd5811c6aebebd3aee32bde2e44713d6cb4aeb8192b947290c51615cabe561d000c1bf6e882f06d270ce20d3a928390bc239ef898ec44c3b9ad43a4f4c3b0e311095d43653636029af0117c53e433f98c9dbf099176e5f07f2cceec1807b36644e96e848159c8d9ea2f04db0d0461512f2bf55ddd9cd069c4f04ff5cfe4a2eff6486294e2c5820200d2d034f2a76980e8e892a35caf164ec052604702a797d1507ebefd1b56fb01a8be020191696c9aaae566be1eea45d2ca53846fc012f4118a71ed35a087b67fbb7d30ca679fcc6a0723bc2e38270aa788ecd25507fe48d172681bf492ab287cf62154baf8fdcbb7e516279c144ac57107ff97dfed9d5ac6140c2403896d986dbd9dd403d5e25e23205c8443e449b826d56fd408182036e4adbbe489713e05e52bdc713131fe9dd89427d7e8f3a1e582704762d4cf6d19cda8e608e6d3f961f41a224da9f688f183ba435d3bc900aeb0e8f682a2b09d37f8d9bb07d11672d9af48de986bf381c8b3d36d0aa78fb48eb2217401cc5c371b98bdbab2f7c4ae1258fde24b4b26c0a8450457a376020d0153181e0f9b4d0a8fc90fd5b2fcf8c38abbad18f494c24e3100856e6f0223d8beeb02345f146a21f5b71a84b8f03829da3c82118166efbc019ae382775a236a0b237f159d5d64a20e7c15bacad3b4b69bcf3ff78578b98d8166f4c5675fa3902e383d382349a4a6c6693e1f2cdd5e0a6aaceaf71232d0ef0ad3499d61055b4349f67315fb5f6d22b96e4b182c2246318253b694e272f3d71d753fea708d506112478b20aa20924c3e68137596cd7b0b7e57bd662a6689ed6e017649a86b779e4fecd9a41a49cde051e2ade8d514efe962e993b6ce69f6399816690b0ec11d238438be31a7038fe33b360e6d9c9d8b453bcaee23ae1d6785cb6b6481c3be3b74cbc4e4512665094a4e12c4a3f7a39dd0aeecd20f3f356901c1f2ff14942bc630b6ae479c1de2755f94133c5c13259847af0f5cdbe7ee798ed1a066c12ae515694afe04d3de44cf0a122302e6958e36c049892f72a2f0a25f89ebec42934de2db9181bfc83344bda18459d76a4c5bfcb6b522a816bbfdb0f7d54cb3aca934607874560e3550c26a075e94500132b58e296d5f850351d397a9b616f36bcf72a71c2662488b6ee3b6e8c7c74325ebd9003fee8f0b4bc4e12597e514241989de3065338bdcc27b0a32fd6163aca192bab549b58fdf4230db6f2059e56cab817f46e01b3efc40dacbadeb6743a6e083dc137bc014606ffca4a8a34f4710c527b5924cbafded5b80c8fa40152ec38bd72912a9556b664ee585957dfd5086c40da1563b3311de1466a85d2f1f9a2461eb8576f69e5db37dfbae5c12d948efa7783f4863263ed5f192c22c86f1976b3be33eff058d1d4ab06acf13ead3db72936a5c44ba3b72ffef8e19878bdcbd944e4d56347458fec40e681c3bc0bb515db8e24d5228cc54c1398a11908deae8ff7596f786bf4682278d4f448a136aa865eb2cc55ccebff636e6438791f89596a884156181a76a8e7d97ab435b76aab2dd107a9806475651e5424b5a3fb4be9a35f04fdc71bbae74d25607046c1568d765e73aa9abe086d78b40816fd19eaf6cb7570d7e9a36a86d7066faaa8dde84d6f83f0d7cafcc387c04810385d1920339289f1e53150478faa79fce59e95e1ae175f308c57af7091bc7dc46f6dcb2c616cafa95ce95a5106ad5806a3dab684143b2c6986802fa03c2ece7fe38f99c4a0e695c9e54242b1b3a0698feedf8365e3ee5e69043dfb02a0749191b16bc7ca64ab2d340d7e566b8d8ec0d511db10f959e175c41902c02fc7703977d96067d68da7b68d9be18f49b7d508ccb38d8e352de27ae0f1e73de21fbec3d73414770c6d786907bbf49dc8eb6b2770983b3379b45ce5a05330617a5317c7d4c5bda931b242622fd8fe06f1e94be1fbf998fcd98bad59fd7bb0dcb9431b2384f1d70827204a2d064e4996b443155f8a03c1632bcdfb0e3896f45048bd38369406fa230a267a2ab219351809866490beebd3ab7372abbd567eb52fe3e7891a2d95fda1d3b38523a91b4be695052ae1e94c167a861f4b1213ac7374582dce8bd05e0f2505e3487070697ecd01ea9a9a9dbc4f2f5c746b206d3f44db22e629174c85abbbba7ab1f9962bc7d6ff22a6301586d17630b0dea17a662597a42e10e48f16835dec309b5419b5d7250811ca23f51d9f8ac9debab1ca3af274d8318ca4a479094a760bf9b2962033d68ba46cdc855e6b6d3a8c8796fd44f95c6f82271b8ef990dd51a973e4c287d403b3199d8a0cfad953c838fe27d017c6834f20774a57b26c3df6cb9c1178e3429ae54e77c96107bf585d35fd69fbf32b68280cfaf966e2bc58cc98127d03c5b6ee8cf1843e09503ba1fd86919b92b33980a752f4698086dec74dc04abd5812e9c95fd8e3043af86bf308768ea5110bc11975bb728b35b4becb72f48a3aadfccb7009c1a5f7d683041e809425e5b9a7de79b35fea829dba5e695f15a0611e26b2d1595cd00d582ea62bc98a4111c2c6cb9732ac9e9ca7be4aa1b19f96bd4a22243355300157f44fc61ef83925bf7b6ff2324276e8c507260c7cdaa48aa09ae1ff8762990153cf8f14a2a3dfa0efebac15ecc371807ec897dd5bfa170ed2bf86a4a60b32af7e716a24b521e596092cc0ed8ae6d40865e2bcf994e371f5db13bf957d049bf015ced1736648741b3e139df3ee2e8f63d79b3e34ed120ec31e482ba452ad835c38f88a1e43bdcb1a4d60d0fd945ba2fe4ec436e95f1e222d2cda9f2f31a14ac70bfaac10e717997c22ef01bb74e8be9551a1121960bd36aa6ca23dd33d56793cc9e45501d92dc3a24bbc7bc599b22ae630d47b8df6e8010b1f383cf0487bb11aefab4060bd6c342504a61738a04931e6acb4ed80b84a147c460899fc10d604901707f189d52de3952ec3a8ff1dcb4a42f422c0dc6c4f06feed8794b026c7a670bee71482d5e470686afc9bf34bdba33eb99faa3818fb4b3690db47dab5ffee14163a59d265124dfb619144eb3b8c09243c19f1926ebdf042fdc38fbd1d526cfcddbe7eab195b781015bd3c62fe72f7609b385eadbf1bd6b4ef45b7a172760afa4eb4fd3479d3343ae965ee91b300194030687dc4fe8749c66e00bd86ef8182b3c8c4c75b2c7ecfd88f4300be3cd0221fa7be90ed209d95ed9f883286337d4571add62d560609e07ece6c0cb8e13fc0cc1b1abb0468e642c112445167ab919a4ea87974374e68d05ccfbe361312b60abb2b642dc4e07604f7fe0347290e31bec1b38493abdb2fee6d40dd82c1fe5f289e40aae8afc1d8746652312678588eb6732481d25962b008783fda8018556623009e8a1c935b9fa1136855fa5c55bb2ab725479ec2e94a906074100b6d1f40f4e7ffdae70bb1d8a202cdcd53c910b22cd326ff3ccbb1f25c89a5e16431b52826f885f82914eb75c03cf7492bc71c354e4b100631dc2bf6179e41f32c38e00c81d1e290b237f5c4d77151d7f3ba649a1dafeb1846efbd80dbdf2979fb9be786590791a6c57fe86e5b33433b8322f11619f5461148c5ab6d2f33a75196e69cee6bcde4c5fb5971e28416bed46a178c75d3fb09be409d070f04e9f99e5d74282c6da08095ba9a71dfa45524cbc58a87c06b6dfec706e37e9b41b2f47cb67c5711ce8aef2763dd945a1c9647f351663c4ab08b2f19da59d3ccabe5e4607757ab71b9a69350f6150475f3cc4319155902280d5415c022652f6e3ab31c0b4f3ac43e1bc81b4e8a178390fa7292dab091b2a9887174fa8b9774b809aedd0bef2068250361018e98acc7707fd2968288ce4767664276ba3f0f14b20114ce2daaf9f5ab53fb5d0b6a6e34158c48f0b783faeb05ba3676dc4c8bd9456ffb8dccdafce76a368181458db71bde6bd92cc71fc305a1a8749095b31176e601229c1ccec09aedbf104b56828124ea2c8b9a86810e1ab504ac0b4fa108f1957eceb4193d8bd315ad03e6c36ee6621866bbe02329166e726c1496f2c177d23436224b8971b950e1544cbab7e745762ae2435041e9d750f1dc3e71aeb836f3542947eadf6f5d05a9e6636c1021d55d88e50ad92f13c32fdefadef92b5a1ccedbe2f611832a94b31e86103dd31670e86b01b8c7297b01605ef2aac0b4f02122785b714d7f94620578ee90e12fc1964ee88cfb47165b825304e21d02f49cb48920353a138d431a42942426bd1eb334ab913e12696e67ac1ff937a40f995164bcda53a425a4fcfcbdc1994856d00c9c0cb89dc1265972649bbe47a3f68a49b5a1c2b7eb3379c924ea7d39212aa924a828913f6cef1bb6e7b40e9a3828c7ac868fd05c1d2274752a328ee5cfc14a025c92ce768e7ac7355b8f854e5e4f0f618a6f70f042c5c06173e81c222f28cbec573ceeb2d36ab846d81a1e4ad732f06cc061b9f9004c58b3cea6f4d6a16d7ef0edbefce16d5725f66b21fc7150924de8d6cdc5d691034464411ff9b31782b2e8175ce6fb826b71d537186746996438a4ecbb4aed798d3b99f1e6a9b0afc0a1dd76ef1f057468307f675d0f29719fad72f0d09d368e93207914c571c73eb67f234b533bc2d69cf6e9d6162eed7d14a973f3e2c7b77bb964ba03aa16d149e3448fb20cbd2f3345dc21c04de9470d58f4b196490bdad51feb4141ea1ed793985acf1223788ac103c9c7054cf0de227ac95bde7022f92bb62370cccc79c98da00c012ab84ffc04573104fce6c60c93fdbbcd279743aa9129e1d604a5349a8d3d0ba56831a4db2d59a25c8e9eb6ca679f5e959d763cc1afd7ffddef6bd2c369efb86785ad602cbefdc423089cff2ecbd249ed2503a1a5f362263544e35f0ea1c87a5c731b607f8fe52340fe1846d9f6c0d1b3642656e437a91fc6f2409c0fcbcbb67dada784125409e0821ce3ce053e76a5499c672e3def4ffdaa8a70acc16d59777c6b45144eab36044459f9a41ae425dfc5a4cfc483e0c66fb4b17ce5515db51e0e21f1802624093c92888820b0de12592c65c7e6b0d273d138e28428ba821d9190cd935e0afeb5d5f13f651989552b7d7f3897febabc485f02edf313b71d524095d244ead3c485161daddc79c17293270395233eb410bc7344ad960045ab46afae0f8fd385bb5a6dd1827bd56cf61e25d808e2cc33f15e7621e778bbe343121dabc1b2b6c59a57c085b794d128658f987f761ba4efe79bafe5156120ffe90bdb5afbca972afc4915de2074cd95950ceb1b087831e2333ccd241fcba074772136a20582b31880f395aa6dba07760c713e1ecc108449d12201218d3397be85d00cfea7b3a84f193a6f9c31ac514181026cff9eb7c87572e89c3de4e4c23b72eb63ae81e0b565b00acc9c8cdd9059aa4392ae4dc4346f7d3d25e98d2cc4cd71b38bffd9a58f1eaf26388f942f4814b2cf62c328afe2b35df2ee16e00221522cff967c724ea465b290842476942db4bb3257a5119c1ccf7417db224ec1196187676c9203c07679fd699dbb4b78e08918714f49f8af827a513a1fe48ec8b2dfbc31b2ea0c5572349177ed799c352ce026c5d982feac901b77197b0cac6c6c680623bfc31beffc4349f5da434f14cb3a1e609f313e3de3b41139691383e96f14726c060316faa34d361a2af5b3e7cf0526fbaaec36b938c9b7424662a723e52cfa3a7a8d1a9ac79954934f908452152dd12fe7941820e5ac31229945b1bcbacbc851c22a9bd2af2cec1a5cf9b83de5d051187de158a4951cd180c3e223ecf2c61","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
