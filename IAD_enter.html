<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7282d46107e5d9f29ad73b3fb87143fdbf4cefb037a7187503b48c649f914d1ff8ee0ec5ee1810b3a5a188f5029139e746474817b93f28cf96ca05dc9d491a1c1fcdd837e4a1476c80adcd7439e364c15434c65cf337c4d4c18b782a53e6df1dfd1d2851fc6ab1d8dd047d8d1c1636ed89f5d1f96f694b79c5318f0b171c2f4cfab0b93b0aeb368c99e8dbe33ae77b89ee2a468387b53edfab161b90a0244d2cb0659206b3828cd7e2df5e249f965865ccb06ed916258d2d7e05e04cc64748b004dd1f2e85015d7d63d8f36a0dc9ef8b3b41d8c364217290eb8d63c394b5ad7b03d037b9347c6e9499c2b18f3bc7d3f500cb67314fddc1deaffc90998e4b55d0d0a6162836b624b36927beb02a6ae60a5fd1db07aa4e0187e658508f4e09f99ad4740ce1b37e5e7dd7258e5d0048aa452daf9cf0e59c5b4378bddad6a31a963cf8d2edc80130c2ab9a171b352f3cc92a193d5144ec9402191da24538d7a68ced506876cd24f41b0ea09a3dd3070816d26c045779d73f07fbea139cf017efab26f75141419ecc6599a0d98cf43aeec630c5088a8d1320cb2b4f0b1fc670b0fb8294e256dec6031ebd765e0efce1d2b60103684881478a455e6295478d1f138ed0efee20ef12040ca47465c50e94445d0d6f5713394ca5da92f3461067349d68f877f9cf4a3a0d12e2d3092a7d3f228a37b4632cd14e70948b4799a10b8ffc19532d394f26fdf185d8b9435ebd2412bb2d01b2db9ca978ed805144380ed839afbbf229a9bb045febad434a3e4ac4d225600e03856ca850c3e778ba2fabf51908aac90cacecd568dbebae24029ab24a060fe1e54977ee5a88738d2f1346a60f197bfef610bdafacb674d36f92989dbb968619fa12b13868df44dda2f44e385e5d1d7f9db60ecf92cf6a020d4c9bc46eeaa7410e6ad671b06d1a191178b43bd7fa80951732e30836db9896aaf608a13d61123b1aa25153feebc4e92b322cd9e951ce2828bff65e56e6c6a1eff7a23a8ac6875b0388ae6ed97390ef4a85ce98c8732f88398c94cbe6ab18bbe456c089155f66bdd9864da2d3f97b9db566af01895295573929b3c7539cfa02927aeb966cceda1b1130bcf58e6fae49c858b75c4a6a2780dbb0bc9f1ac2dfe65a7cca08afc1c257ad2f9212870d69702b870c1e1e99f9e53f72b19eae8b69c52c116f975d807ba4ad66c4e07fd9bd42924bed5340bc413bfbb54b47a884bacbb1bd7497a9d36a43c607e111be21b4fde7bac8b4716944877071a86852ba99e02b010dbff7724b2c9ced9d476579ca791c0e5e6d077b435dfef560102d9708160573378281b1d975ec25a0d9de056342b87e8100231dea7c6739b4a7662b27f442d3a0dc5995b8041b32e41cb7c4a6bd55781562b309d1fdfe72589a48cfbf600b36ebf6005cc72ea069c2734accf2b138b18a6bdb056911bdaf0a9bc4dd40bc40737771242c7994cd8f49a481190adf3abded881114f5870cea817d0837e3e756a99cb47c05c47d7676a9b8c6fd3562ed115de8623b6fd2be9caaed58c3bc21f73a4cf3a28f4fe0676f16d9163d3cf1c79b01995053ba55d9c1e9f2160b5355ea5f6253b2f1eb55d0c45d40b5507867c4df42558d40bc9fa50af39dfc239bec13a05b18f68bc76cd5b697b07a9c523c2599246a9304d713fd5ec89530952d05848582abb575606a25f716200e828ab9a292172fef945559733b1d7b2a15f5643d8cb76c3ed6b59f418006a44aa87aa8aed524c67f28581b69691d452612409fe043428f8035777df5fd485ef6579cd0c9c99b341bbd1cdf4990a6e16cb34d24aea6ec7380d93352f22920eaa2a31d7088106c6be1cda6ddf5b9061c7b56e4ee774bd97a73eeef01c92c82d142b5c9d5461acb5bfc1b9a76210671b139a4fc530566d103fc48f1b459f1435da9b4fffc0b10bcae75df4a80041f78a20c2cb6c81a7a7a98ccbcf33946398f7b433f3229a193f0e8984fec690370585093e228dc3a19b337dc1e606ed1d11354354e8f79614b2f9b71378fdd736a41d4c133e315a74a35e5541f015dc0fca1ad61be48bca74944b67a9c28e12466ccf637fabdb9a77dcd6af2fc3d8917e2a148daedbb699155fd08ef1fe324ac7d6f65ae430aa50250b31d8a2bcbb6b4bdf9a1b0d345611b27dd7263401b343e91e75f57042d1460f261f96cc6c852f2b6bb9094952c42418148516f3ff5e11f84864ff463a34e4453e901c89a4fb4def9e2213b9e50ba337dba0111a098b6a4d8b4692dc8c99356fb0050660e6d5a1db627b8eae7cf702584422f06c22c96dd4c7d33be140a9555ef24ae82cd5df9f76277603f2c162a039fd7e4d936accbe1cb993d5b6afca1215bd9add688a32820de9f530362bdd41df2367e81bf4b83c888a2bf7fdf64a6e6e984be551c10d17b63b6f3cc087c3098eee3702342871ac743cb2af81015b577a77c09cf27872d5ba65e21304ccf611cc4a62dade4ae2dd7c8591133df239d85ce65f1252ff7afe1e9598565be6be6e0d54f00ceda25d379509ad7458da70901c3f7b2a4c8cc3b76fc2a71b14041c6a498165fed0fbb8039e642fdcd2ec52ba36d61c2ca3ee575b3fe215e1e7c1389c65228e50eb8e77439400868f87ca99f6ba3e80c53b211252dd1df336bd228f1ba08644c79422089e04e2443eae6c3e85bec5d732cb1277a0b06dce6fd6ff27a599b97af7290a5c79814fe1088c6b19e73c02b2e5aaad4b140f804864b6a6b81b10f136aff83cfb4934a7fbffa3356eaa9e677839514c4ea0fc12feac532be31b25013ff191c2127f75ce8053c1702f0fc9f2125681a52881a021ad4e7f6ca3988b97b0b8e25d6497174e45918c1cc3e7f7a966863e0cccef2ab2b31112f9390fd78a64a9601f33aaf7b1c20d62e5d52a2626bb04f97da7093ae1a29eb2724130f8ae220bc3df060d234c0444ccd9eec364e0418d81a73e79f11496782f953e9480dd373e162285acd73db411a8c643749dc4e64123267d16a21caae7fcce59ab7e9389b4d620d9c340f86104f83f338de91206d322d83d3164e1d12116a215cff2d6d522915e351094923df313fe66f7aa1d8ac9dc3009794f320be3935d229613d5d7e47bbe8c2b8611571f6e137d25612073a9397469915efb3320e8b49eb3db25421a6d447163a28faf2fe45b31f054cecb36c73a46bc610e15f793816c2db7da677f491b7016e23b8f04b2346aa0830280f872ee5d88eaf26cb604f2b5becb993ec0372ed53b9c7f4e0540d74482ef90374bef05dd7520bbfb0751ac943292c90a6563baf809a2ff2b7076b06e1dc6d082152dba3307a403ce979d5990bccd6d41a6e9e60a97081a8e58dee4f8857ba6dba5ad5f5b7c479431f7025a82bdcc304985753306e32c6656cdecc782e7d93c9a525a6e618a575f1701d55efbb5c3c086bb3ee606cf3edb901189bf6e538ce6c02973505d5f6516be287b5f913eeb9af068837197a379571bd38db5451230f50ea47e8f8131855b7dd68d2ce4d33dcd405077123f95e5ba5d11396c24d152cadce320807665dd32872a0db9996787a0b156d5f0f19e7f6d82c47b033dbf417fb5460a4a4335fcf9a5eaec9fcacd52685017afb2ef9d49be6b1af53d7e0b65e11030ccc654b12eb81949b7f0e428b1af1387baaebcf28f29775192aa254c7a44423b1df14f347158508a2bc2d57ce2e5bba42bd0904fe272a2cd0c8ad2faf846918ce36fc9c18cb77360e6b990f2f0fa31ddc9a30faaf4f29cca08ce93a8a9cc88a69003806a43f23c2a23f1048b1076736767aca967d07a90411350733c60fedf71a3257c00c88f313a683b04a9355fa210255f7a1c1ca95eb4ea3818b6ea924dc392e2a7550fdb078545ee7a8f0e24ae4abe7749b96a472ae903b8774e5051c234f109b9f9b7694ebbd015a20d396d8b5db9dfebcdb0896fce78bc5a6dad013bd47571e6d5a5e107563eb8a215632678d5196b7b7d7907726d5b1948cb6476458119e75acb04d72d169a77b61caa5b36eca55ec9d425654b988234642eb8f67d93ae1a8afbb005c5964f18da849ee1551270f44e8fea194a86abf28d1849e51cf94d3d1370b2725f4bfdbe5f2c1b8fa1c869cf8731c48c43ca9a00edcb3da02dc0392032192650303081031dd167ef9f3802fb9b9f98d9276312a50708adfacc14fe2ea19bc859ace5c2ec2c6e68b9ad8652b2b428208e32c681217705f7d45041dab26864da7e4a20b8999670d805b8f3e5e501f4acc3c6c4681fcbbabbcb639a5d084330c9536709417992fcde0ef39504f20c43ff117caaa1faf0ed31f94f816cb50953df8dceb85da8c401d236762e1e5218ef915f3aa5a96db360f9d75e402f41be177134f54f4cfeea55de3486bc0c3eb7d67ee9189ce94b2c5e975e524eb35fcdea5c7ba6329785350b808c0d175090c80b54350b240957e365e9f5b9585791a1e621972560695e633ba9813a347a55ed19b5f2ad4b2eede6ea35366f284ffdfd247526b70ae8550d9ffeebae99efd1d7a243bf6133643d40aa6cc682c1a4e9e91eea8dabec86bbbe517390df771061fc7e2f1f9162f17b51fc77993d96c5394ff03e4c56318317f16677e033b25fba661a8dcf4275bbc1c379b23eb00300d6c772bcd1194fb18a056098d1382a3aa4a1453e1b7418449b3addddc93e9b4b08b46e29e4397d280c785036a93ca51ae100e7e2bafbe398ba1bb80a609563d993cffe57cec136f47296c0014b56efa2b1db69164d36ad95beecf2ecf8c438f9da28beb0e485506d439b7caf68ad0d77c836bb6d4a29245adea1d2f9fd0bb2bc21e01456dc4da607b207cbea4136e14fe5f567dcd0149137cc0482c530fe2d90b8331ede06ef5a78b04bcf5541a9497f13d5d13f1b077976b7e208de1dca15b14ff843783273fce4d92a7b2117c22e5ce144ab67d270fdfe1358fbd5130101a96754b12b557b5b37227729063048de5bc314156693eee0ebf82165ed7aa6f0f7e4c8777335b255b634df9abd16e7820fb0af316f7d6c42100c5757c2644055205e6af936a8a853080e3e7243c1f271ea4bf829c1981a2fb1310ec8db76a04336dc6d3555c3e4b2c616435f215beb8de74f241e0a4e91b50db1dc295ee8633216c599f66cf596dd7ba69be334652c919378cf346e5c9dddb6e5972f5e5236a8c9cbb64a13a20f7fbb36626b5d67a5ca4b3972a784e125bcb80606d170c1c02503ae215e61ddeb7fcb536aa8b0d6fd0e816c029f37872289c242c3c41ac88aeb37ff3f9082b99db1a6e7b8718b8c200cf0b3d78e0f403ee2c7316c2361681fad41123d2989fe3f35c3dd0658bb4ce8d6db78f4780e3435d78420e0090cad0343a51d6b2a8e2c468a462d3a9b651cd4234f68b29d7f08141aa2fd2e0c224ac3f398bd7d47978612f5467002896c37d28084d8f91cd8fe14969f0013a4f9fe0cd67f2d34b4d82a3fd773af429eae8951bbf02ffadbe72759680fa9a1ea2ff2a7058acbf488289216c31ee7f4f3efb31bb16feddd9253a608fb1f5d8caa5818b220137a6ac0b8b982941083179a206ead9019723340671acbca6ad8bd5a654272c39c111b4f555dae3ee2386e5034109d5d36f38332520ebe5017566a478965d610aa68b5e631c1faa230471f424c6fa96fba737759ac358715790f275e99a0fe9e5944c86fe960bf48b8b1fdd0fd16bdf4f096d47fd6429a16f61a2e976f839d7db4ebf61b06c30753f1d65709419e626ec4f79b11dcf771ea89c74f90a67c54138223a2895867e4f23c8eaa0df74fb046903f8f89505095407a9631a5b34e4106b4a498dee4eb28887d985a4c4a9ef304cb09e74c3fdd582d5ae84d85df725b9d41b372bbc24d96d098611d0d2fe84500e99a0d362415a9c701fc84c36d02dada67e547752c9a0bf5c98f82add233231e6ac564d0d67aad725a77468b9bb16862478c6539ad76a01098f90ba61cd47cfc759e752ed2f0c48298eb8126f37979b5c8d6d47e827762777bf7e20f96484bfd70290bc31434265b829c1d9adfd149ef2c8eea747f3430daf99f1d84ddf40b459a0aa9015f41754d79efb33131919ce30023b212f2903184d187833a8d427bd0b606f1410a3386032d0f134d8985cdbc7e8b89e254c96ccf7902f7b5f5efb33e0f9208c8c66ffdb1d268c595059fc650d5009dad519a89f610c986a0e385d8470eb5f029b3b946647644284f84122af30439e8e09b07f79597034e8617e7c0b256c9898a844d3128b398119b507b2f4f7cb3a9fe2471492d3874720b7357bff446b3014107d64bfb073df0742d73827929522d88e8a88306a82227891603c70ca40355ec9376cfade8d0bdad5b2e63e7275c7d48afd676e1f95abdbd7921917273454d999a2105d4c81dd23d3e164df687d2842f28b8c1d5ef12fab54a9db796bf5c5e57009c7504d262c31cfb247f4d6c1e8f6db8142219fbb8dc329d365d97e966418c1791b2cafcbd0a49bd80ecc77e011fe7eb9b28bfc2219c12611302518fb29fe31e2c440e2c1794a803be3fcb27b3dd86d31bdab3e7c450e690f1a1f46e2567c72d6700bce24fa9c8a6e77e3164577f7c0429d8dba7ebec5647cd61c25f42b35091391e843102f573c9121875f528c0eadc33974f696337ab26f80342722ad44194646170d26bb344f997d8190e015e6ea3de87f751e9778ec760f13f22c9e5c45dfc9227ef6a08205b48ed4c3c241744f1844ae27fd682b580afacde064507c7b7f0e84caf2346501f7776e2b1a7dd70126d94d5402aeb1c428dfb634e0f5ad2f2e3ccc9036e36f5524cf0af6bd9cc875352ec346bfdfea7dfc2535122a78d17195eee89cbd256d4a80c56bd02823f25929e985dc5f6102bf284cca12c47ced0206fe9bfa4a033296fdc8446c511e6f0cbaf7730a1795ee5c2f48aee5fbabcce7b4eb58c13de5915004ce64910873efa20fa070599e45e44ea0b31268d6f1397364b0ac922702bd4fb8ae4c8e97ee62035250b613b04ed010b578e9b5f4d07168f459f3ae4a457db3e8f3be6b3bbc80390dde7e4bb78be8b1b21c1dde828077ffad6dd9a28e84ea0b2603c0ab56280f0fdc2dfc308e00ed10e0a26f1057a3713a53277bc1a4b3d5d59cb469127eec306eb8387c262e5063b0979c4f6a5012a80ff18d12123f9de2d3fbe83953c299980f38f80ee034fd471ebe95b96d96b7441cb9204b76be85566f9a0bd0186712f01f625a37cd47d370b6d2b84c87b8a95aabf6830e733736ccb0a239ed609f3911c70536a2304684854ee56543dc91201df5db9f38d6b4dd5d02cd7e55415172f3197a3570c597cacfdf8368a2dd84b5ee670785b5d20c9ce37a0fed078d3343178c8b4bba97435a2a40d0c38ad48b7279750536bab889f511c082ecb6daf6fb2565ea4f62163811dfe8531b7d92ad230d485463557d48df547046613d7c94b0859a9f6fa8942c4efdb65d22399fb7335cba396f44a05756146e8063ae32ec70a22c89e7e4269b1187eb220bf89045c7400bc47fbaedc9f9a62958a13b9c210cfcc736188b3b2db502842e7abf663d2d66562687a1be78ff6ec8acd3cb46cf7eabb61e50bd9608582a59fa0f88b18eeaa625c7d266321c118d972282bde617f39f66858fb727801ca66335692ffadd4f04f83757ade0c778fda9c142a3fc58550aec46479ff616ca2fd0f1783199aea246fd95b99ed5ddac99fb5d84d9f275facb7088d89569d265d9dd14a43ebb16c5b6040b16f3d9e4fa65bf4a896a243b2146818a01071a19c2abd15273680dd26ad082b26c6ec46a183c69c54b860d80cec624a39941c4715dd6566754c93439467debc12f5ad6758cf9240469ea9bcfcb425228d7f573e1edd9b43282e0b010077ad53e03f9cf2438229389fc7b777378b483e3a6f44f43830590f9bd6c372b6c54392932717d27a5396eb0aabb0a36e49859eec10f343f80eb5cc5fde5fd9c43e07e450f0b4f5b9d012534082eff9f00baed6387844d0ace3d2a4efb40458c52a1440f9d89459514d3c16f0e06ee3341dc3ed5067dfb93f19cffc6c5af938fc663344fdb72e9664edcd5ff4ef0798e95001553419500c0ff88f8479d5dcb622844d4c3dd677b5c4b0e564069effb09ff64a0c9144becfb16166ac5864ffd42ac34280d50cc6ed373d5fee4a7ec963d1ffacd57550831005c6da88ae34885c9d49a53080452112bf4f1b3466b3537c7f9ade4b2ad8a0e710187088b94ee1396fd64ac25c547df8412f6dcd92cc32bb72fdb46df6d70a327e8c60f130dea7fbb613ef132e0e41ad59e911c6903f4a08ffce278552950881641f44a9b25a3e978cf01745de3bc6589abfabf080796843675a7e064c506f72716aca6dfeba2cd23a792eb8b3f33fcbc79860f4e7c4f45cd8a954ad48843d4accf8805e33ad339c852c35983176967ab540bc9af4063991601d540e21ee1ea4049ba39bbe5e79460b791b4173c1d6edaf6bf729cb272bfef177a6f1b209a1b1172cb12657fc3aeb2df8ce89ccbf991b9b1f8c425b5b1aacc3c419ad962fad931b67548cc17e8941fc14eb6dec661796dd1d5a8a8e6d3bc78b64fbada236d5fd7d6c04c43bdb62710359bf77fbdb30aa02a10a43c7cf3aab2b8cf732043b6cb1bbb43cefc610cc637cf855ab2667ffc77b4449c6178f58f6565e5d1a07782de177a0a1a0fc5dff6e31ce9dd361f3fdf5d873971674b8ea7af831c963e55eff077f89889bc593618c36191c9f4d194b9feb94de2f9342a5f1cd3623527028d59b448307ac5bcbe79ea4222bfca407eac0d9eed0bd0fac62b1ff81194945bff2c52289dc54d0e53d946800f28aa70f2728d6a6c73105977278fd536ea0434e3f92ef3670bd0f3cab50bc594a52689b58652e7e346d48647d45f13a5fb2b2333fe0e3097734c77c403d0cdf16dcdbb4e88e18b7ee6e72bcb024edae01bc14d54f42a2e09795578546060d773a947ac6e53c2bb810a17f7716d69d88deb5510d3db8f8153216b6a501f2ece8f545606288f26ab4c8eb3ba7a6ec2b4b047b93bb97636bdf20efb17d74a310605dcdc79a53c18b160bc7f932c056cb80a5958ed42d4d0001b791a5da2d8f3dd361c040b595f0802d50e92770edeaa4a4d8986956efe1608f164c73fc8b77d7d019e775007d50274e193664cacdb1b6a87f76d7ef8c04e242ebddbd7d124ac00e074012f8b5f3f265eb587cd75b0207d65360ae9f83b3c90a96ce3044d51ebeba79dcc9c472a58ff42cf634e68c55149d5cdab356c0cdf6d7840726c62b5c6e58b19a419538ba84d51177699bb4baf9acb3d433b1707c544623d2ace2db9ddeb63331349835bf19d07500a79fb31d1885c140175317c7d8a6aac47ffeb5103d2fcedbd3256a69c2fbe98cad810fcc6b351aec274512f3c043217d3c00397f9c510b6bc38711e684b4bb4f2c9a640920283dac1c33036ed103375408fd6ab887d8e335ef85d8125df1cd7ffc3115bdaf823cd5817b7c2cdf162c4c51210066fdf2192ea92cb563ae433ed661979a62c7e84d09986e768b0473ae18b59f66147976ce4213946543ac63508b4b223eb67603a703a1c57ef893e89b0960b31b8e5aa1f163b2c7365fe6f2a34ba15e5a1b885074a729eb697da0091e2680fbb203779a80014bb6b71c7b9f42d3fc77ddf554f7bcdf0f1f9d148f89f76cc525242293ab3653134faabf3fd8d279c01e98eb590fc0b7668dc99e92d3ae9a3e84964fd0f435d4627760ebe530b52c6320b0f0e2d36b1a52e2cc7fbbf4c29fe4592f63d4cd01451a7ea0bb4f2ec8a8296b1346fcb550c42ea259dfc0ea9330962738f63b36176adcbcbba2f2048f7e641937de3cc7e70bdfbe31e7eedc97a83b1592a2333095dccb32ca785f7ede7d70eb12a488832088f4dd57bd8ed1c3f80bac5d5fc6acf565b8023782d52f36436d97ff5c8f3af5109d3d942220b8b7a748a02bcfeb58a334cec501ac23b5bb0fdda704d91ba6d26afd384f5c5727219246f78b59da81e05f4221186b4e9d1bf39cca46c728b73ffcdf8e9ec810d94a139acd4c920156b333cc52dfbe650cbb9787267d7877dafe45774c0677f2f9b2db9a71dfc0224239ad12d676115f461434f73a6fd3dfcefa6b16c3d76de10ba73671bd654baacb713334cfc539d216dcdde96ea8d7a6b20f5416761a702e2d7eaee51bd6ab40105ba020a2b0921d870fac57e579a7dced22359952466a9c5362dfa81705c7e42a226abd4dfac68f6f66bbbdedb1c2f9ef5f27cecaf25227ac13759df9c57cd1988e85a36f692d93355db05e41987d31ac32afbfaff06b06ff4d7c641451598fd040892a736dfd5571ac6d0deb8d8be007843b68619ea33c43415a78ecfc614f261dbeb2269298f9da952d56435b2fc14fa7c5ac4ac222b56403f869020ed0310d05438b5b05f0de31836b73142c4fbb0526b0e10f0bf0e104b40acb414437a438eaeaddcba0d077933857338c1643ea88ff7558263128f95c1296674f497b75eedd343b157c9e2ad9bb8e3aefbd399457bfad5cc38bedec72718a12ab4437d239c0c24fe7a534f4472d9b84174dc6191ff4d69095ac65ff03ecbab18d334f02677ad014a69d466769e7a7ff62b04fad4ca174e4c84d9f763f622cc8f7ee9a95b353322e1357e0e92557a86106694858136c19eabe34f688e412a0ec30007089adaf0048b3c53c99de5d999d613015a0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
