<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f79a817b9ba3626d23828e40aa2096c1ae0b02ddc764bdc1b5a5e8e7a2ec5ee7e0987138381548cd800405692a3ca8b2d36be5f7aa3909d65310a28cbf4c6965c0afb4e436c6341305b8d12feab081eaf31f2d2e610dd407548b377d8ce7fd9040b048f44f97722081c2f78a93fa4327260e172e52277676e38ac78890cc7b07e671da08b384a29ff268b6695eb7354eed8a7958bb62d320fb7eaf8f9ef3de302d46cbcf91e6acfa67460481cb5fd63f5e6e3ea018e1a2c3c4a9b15df5d26c97a6a79e72a593c0b1f65db7ba31313757bd5fb0bf947e3a013dea226dc81e77a8b8bc5b2649a88c9f0a5dfad70a6faca16253169cd319cb00de6006d4be54c941a7ab86d7d64d10a84d9ada39e426b04bdf110cabeb6e228aa9792e13870ec6988a6f75efd39088544085e52a77ac52bf196b90d2fda4737032d49713e63d783cdecf604c6e4e1261aebbcdd89cd028fc0ad1c25699f8524953952dc47097e34b7aeb148d552e1f69097d12d5edc2fb4eed5ba20d3faa71413042ce0ab3278435cedb7ebe7bc04bd96addbd37f064e222bd05e6b0bea34e195a4b6cdc5916a2fbeedf10974f526ed009b39e01b87d8d06050aef39c5c5cc387fed112edd77ad8bde8789526a150d587250132c75cab96ef55aeae05238801a280717e9a42134199003038112bdadf75a8ed2947ee5f8b4de4d50ce4331908bd9dc624f806d5d23b275ebe79aa9dd28e554658c7676e45c0a65af604e0e3e014da56e4b12bf087bf376c1b1e0dd02b01886c26f4fd87484889cbcdbd52bbecc32f931259df0b302c980705c1fbf4a997d33d76174b8c84a61531506cd39f674ba840d9c5c64935de64f58eb2f1f9887dc9c132b5b76392b9db20dfb0f5ecaa6a2d09473466dace839e334dc83194704588790c2edc6a3e33752bd17c7851f16ca1312538c95be17c89ed0a76f8ee52c03eb86fd2129c63062b02f2cecf9ef0e5b7432ab52fceb1a73ccb94f670e6b909cc7d66bc73483167cce1b860c5ffe35da70968be3f17ee1c15506be340feb8186be2910fc9ceead3b4e14d2243507b02f705c950bd99575a7456df9d3c979573cecf60d5e6d9e1a435e344fdbe531ec50b5cb73ef9ef26ab16be73d1aa00900c8420cd477e33f1c261ab6e99d16eed543046ded76a220ac267d3099f01e7f80d1f6cc8027e0b671d654c8da5b15760409c7ea3247d8ceacfcc0149529acc46cf2b75196257a6860e3c1dca132ada03c7003a23b2b3070e554ab6b28615fa474bba48b7d4616f580689fcd02e2b3617bd49d7d6e0f89d7b9f27ed9037e0e032d2d60b4c7295670e2146c90e5a1fefd8b5d7632c87b1413af404e53a86b1c9a4b3df2101a37e8eebb32fde86fb07f1eeee37b58f201881e08d9bded2b07473012c2be984ac54ce3fd3fb04488397fbeab7851a4a966317e73c22b4ae9d2a5a9b31fe5ec6800306eabb7f78e21482c9e23cb3bdf65e4819a4d4b1bdabff9e5234e5b41b5ad4324f174a4dd383db16389019d06e95f4f3b3e1c80ea72b9be7f3c6b5574424ce36bbd67cc113ec0dc0c79ea962e1c5f80d41b03fdcb9f3dd0c4ae15f45b948604c3feb119014831e86e91a88d1cf133e82a6ceebb7c5d00cebba43753b22a8e7bdc4e6990f9ee02aa8e3fd8156ae5e1ac08175e6681ee778ad4c0f23e96458669f5fa73d89cbe5e0e3dd99732affc01f779dfa46e70bb620ba2270432d6be4b375f538418a8ae1f1c8e03b59eb4fdcb175fa4e571239674a2bb74c1cde0eaa796c1ad3eadffac89c6cc34c490f405ff140c53c313d369a748ac8b7af5ad437c5b0b08a57ef83b8f6301256d97f2b004989ae49c98b1fa4f9d1580b8a781041a50582ce128a6df848d3c83ba7cb5d1028da0f252e569bcd2819391bd7d0de5d4f27faf8cd3d1fdb1ba11274d8d0d64d1bc994d923e4d928722a096c1d94ca459596fe09a44df8375235d151659fb4c66210efa02d4df0cc9eeeee7cc8ccfd0b214342dea5c4c655902e0e58c4d53e4cfe8197e9047b2612be9d7e35a59bba3777c503f4fd23b696fcd5eb3196531e381a52e31c7d0e1924fcd1949369e0d2aea2702ccd61bbc99cf9c9ebe8c6ffff74d81e0338b32b8d16c3acd8bf1a29728e4466f35085d760c632a09f860b3f0ca262db1ff6b6343beda955a5c8314038ae16140294efe8b2cb1e7c03d496c1f96b38c01f9e22e93416c07505aa16e4a16173f736169c64f572284fb28227fcf7ec7c418c8c74ffa6b541b68f0f961687e90644260f7978dde56b18b5924bbc92505008644ccfffb72728efd42c7dc2733a232807816a1dbd97b45357ad8cf417028e6873dbbd70affcd1fae615663e292ea159b80efc9c8899f0a69b33cba776245d19e9bd0083eee19df150f52808c29fe1414883d413a1c6b547f42f65fe017edd8241b12cf342b19933a7def79f0c0219318c843670657e6139f01cbab77e590d41e5e9df377b9b20acdd14b42eaa61d8103bc01f9aa50a69a86557cd1094be4269773bd1b3ad4c15cd9b77051b60dab329dec710e97f9aa0d500aaaa1daef382afe0ed6ba3d9838a78c9aa4bf17733b0d8db6c72963dc1c2a570711a0388482c527eba509aef0277ebba203ed6ad28a4d644b20b8ad975c2c5853919e2c745c370ad025fd03d8c50dc8e49336cb46e48eeb2a98702b29bc584e141f286ca976ba24d9745cda806928054669867d138d0ddd261cf373aa8046d6240bff30c4335ea00bd58d06654690102c44096c8ef6a48931b13e438cdd625df562cc1e79b85e240d644a6a81106af13ec52db4d35db8147e0dd284d1b513bdc92a392459ca788566d564a6f9561fa6ddbf67e32c45067973b380769f9b2132ccd864052c6bcad61d775de49505e169402884964654fecea2bb6f252a9e56f57df8b05e25abd2702fe83047b31d68fcfdf7ea9041f01973ca79d7fd5af805da2bacc76164b54b4dfe9239991b2ea9af2f1ee2621879ff70b4b363c8526b29aa8b9e538c309938421e2898d8b13a9486fa20b9eb44c4cfa8a0ae47e1f2753feca05231c6567354d7b9d9841504efc2c0fe1c48e5a9a0725c21831f9c56cd2e97c2e55a4c049754984eb010cd37f27fdbbd0a9a61f979b38d16f96d90e98d1eb358ec55d6cec95b33f10e918433729df699068557acc33816dacdb5bcaa46afb40041b3a4a6d8728867fda231f7f90fbdf42c030e1f49c4abaf387731cff82bc027725ce682e8aa65dbba19450623a6183ebd8ea4d6a0ca5e20d7b34e3d6b9294406083cf96df8ed94ae0b0fd24b08e35519dfadc5194d0dabcb0b4a537d4df2b46267f38026e3d18189dbb8dead9540a6e644588669370bfdd0a5ab5bc1d512b1906b1e70ad368aa79bfd555c22320b3195d6183098f7c987f9a657f3f7a661c5c7a339ccce19e0646e649adc2a669451fdb862dbba7321479e7e30a4e14330f881b6cb812c1c63fe81b06fad95273165adf9fa05b967cffa8d606f9ba983fbbef4b48bf4f67b61a1c7c6eb0b659f3090685a1d69be4f6500d9ea4274cd76f09b0fd30dcdcf05054a360e39296a1a819c9fc89ca549ffb6ff182972c865f07212dff7025cd8f726a63cd179dc22f09bbdbe1557c6311041bbb7e29cb0afb21d6b0b8d23953ec0d3ba9fe75164d31fe47c4e0a04360b9ba710fee07492ddcbe2e48dd06f4ab27a2cfba53cfdc98f86a1257df7330c854e36c240cd116cbdc35078fef034694346df19421d691daf1b9676658553dc3dccee84c809c2a8b472a137a868d098d8aacd7c65c1fc72d33de5362e25d7c5bac9606134cd486d460437e0e4bc4e53a13753139b3d0f70ca9c06add49e29685a061c0988c9d20f8ee8dc0a7b0474109e5709ab0889cff5ff4005d1ff7abe02d5a04a974bf14f809150b02a8cc3954e9023a4ac44ee009bade1406f0593ac8b1414c0d108368f26eee200ab8ec436d2b8120d331e2e165954b6addbd04abaa80dcd06c2ff873a16e53dbc122ff57d6c7615850b7f022f109ba217d7208ec7a9ea6be0d0052be242d5fb5d50e0ab653d9f527a2cf01d8a3616cf30001991327e201b4df6d018878f546d3f8727305510f1aecba784c0d406735ebc8df57a86dddd170698bef30a730a4f7d6449e9484cc27b65f4a462cf5ecd4efaa92c6648a6e931b94bb3fe806f0ee870e85ddb47c8f342935643bbf551aeaa169a0e8db1ab17fbe5450e7691781013e2bb4fd8de7c2b690322b5c77aa08d124d41d13710d5b4f420fcb1ec00d7a9336e512feef3a93ff243305747fd82cee8c73f18182eaee8f007caf4f3b3b77f2e3989aebb6259e4c80bcc60a1d672b0525aebe3d9abd49a53d7a4d64ef8584065ff06fb7ac15e7c7d41b48440dd422cda39cedb47cd78e39993b1beb3e8272685cda198268748e93df501c90b7758d32c4b8283ab3c516c71996019165b07a8340c1506693b9d1bc1d72ff095924ff3c2f4ccb31276e98cb4a6d4b0b9b09ea65299b554c0865194f86675f914c0d0d32810c9aabfcaf33bfbca2f1b57b7863368007230a2a2648be28f03b512dc0682fdcbd765a6ece2e6d753302a1593ece9d2cd26129c9f4e5c2db42a37f39e0e43eeffc5f2beaacdf7401d98840957c044f068651d742c68c2b4a4aaed8a2c493eb4bee57506fc900941b707c12ddeb017d34b5375b0b505e3977df9e41d253cd4680c218f7879d38743caa740e89b407f39e43e185d4e71bda84dcf36ff4c29e1bfefdeb56c1d649809c43d013e28f561d2090a3ffabae5721badfbc7780c332c0a76b796615d73cfc0b189b80d5a8f53be55b2febc69879fb472d38f41433216bcccaea13149191eec06b74aba7d21f53f6d52030222cab9f665c7567ce65cfa510a14137709e2270ed7efdb59e3f0fa62161451aad76f6e74e9db855016df6a265b2c02a936d1461a25984c318528b48d7aacd7d2a03fb8bafb61133b8e43b24e5fa56a896db94f94d2ca6179dc152f25258148cbd8eeab48cbde90c76e65054eebd3031e3c8c88454118b5e5e13d35d79c9ca8e85bdf2763758d1001a688a3e5abe737b228105d944a0ee61a2c23887ff5ef9e5f2296aeea56d3c5f202796f3a65757053c696bf859dc6aa0cf950430323b55418869bb149292eb4aca31727afd89084f9991522d510c1c8a0e9635f69aba91691d821bdbb39a9a0c19c2ab54a24dec0d50c6f083b1c779cf0f2655972fb98e350f827a33231f064ce8e1b6071353e1c1c938e1f7ae8b9935435b1e9bf4240c7cdaaffb263f24915bfa1d9eeb65c72defdac865b3a23a642d0188897e6b376ec48fd166f9edb6f2032cf2d3aa8fae1a6ddf4c87c7071287ee4bc69071ba4da2c13720c7be7293fce8a88075f924d70b02ba539a2c050b653491c6c09c1aa1d60cb14a222980fa45ef85a498b5b8edfaab0df8bdb4a5b9f9de55b6518748f62a25311648ec5ac72802083e812c5b0bd5b3a2e4d1d879f8f3d3427d0aeb3a398e5f6363827323b25a24746411dc4c8e891823dbd10cb92c30d43b6bbf92896c9f99c6aacd23f279374c72364953e7ccbd7e5a28e7938f6ffbcb5154a2e87892b80cc3c1bba7439b1d1e78a4179b28b925d92c4eaeae539eeb856b6f9d88623f7760be0cde31b8b1ffda6057dacc497b29aaa7f23486e1f4e545d7252ecf2c6c2b21e5076ca38335f24a0d94e678a45000bfc8eab24745b56f5bce4da5471b544ff7e626581b73c352a8504d5ea41708c9c7102eccb723dc6965a5b5b6d37f39c81de2672a221442b13a0419cb26a7dff5a4801c1e81c49309958aaa7054f205b7803130b0bdaae880b6fc01bbecbe5c6f4bb07ce1f7535a9865a511ac3a305d79075d18a9f3442d260ac4cb25d8cbdddcc1723331d145546efff03ee1302033def8f34f75bb3abe46ed7558e292049e98ee55d4cd86aa463a267ad36fcea660b71ca5a3e1abf138eaeb58ad3b96c831753b2127bac5ae1e8e20617a3bd5e4a097054bdb44ee0b88c473932d88621f78e3f0d211650cf5dc6efe6625532c4921b2139f308dd2314df96b43c9da1ac3f031e036a7bed1aa850a413c981ebe4d363af87f91a039598f8cf8dbc2efadf8b8ec082153d25108b9a5224a3b60b69493c6ce324e29159afdbee8ab3d3225e858e2a504cf18133134ec57fb739121d66c29d68f7d80e4267e3eabe4f0a07da15c318ae76f1b9b82f8f751c5818189600c565e09a5c5715e919a9a4ede58d597bca5eacf40678f06099957ae26ecedf1111c9a70d50bf3285816c7db09cb1b2e6387d01e387f7a03a0606535c13ec0367cfb0190784f93caa0389ebd713c905d7fc9acd7ba9ddc0c81c609604ac3ad22829f000b845375734a205cb49117a6bf3e206e0b740caedd48872599a6cd33846df3e25b6ece45009bea8163c73f0f77aa4036e948cfdf2b53fe3ab7c1e25695937e4163ba97f72b3220745e2cc1032f33c38fdc35c0ef38f59f826d883cfd325ef9ee878aa7452654816a8d5fdc1d067fcb26a9605013456b67f6bc2b81ee3111ece867155da711d42dae3fc2106346f72fa903915c3d827bd6f1c48c9b6dd99459f65ff70e83a10177ec4cdb0615bf9ffc0a77ea0a563534856030b54cae3fc036303d61e24e56dbad37e8277bf0310e9f3d79697f32f32d6845499213b5ab7a41f6f20d87709a6b2cd0755a860f13cb1c09569273f4a6ed6fc66fd7504be87a2c576eb28785f55868b1d506fcd18b632b10fee0b8e7f94b392bfac4b9938351c912fc71698eda12a752cc500bd57ace79b4608f8ee7efbab8b6c20aa0a8647cdf9c3f2887329ccfe08f3c3e33689927b386420efc430a0c0a02986ac4ae6edeb62b70c8d0f300f62633810d3447b969694455213c39ed335a795928cfbcc8214f685ce6acc83084a0165ca5eaf485bedbec14e8a1ba6b16d36b1b743aee7bb1b20dac7fc9821945e1214a8affbff0535556ed4f8273b72387055aea8aac9d10041408388db57dfc961e2c20a3248105bbfad6b44e57eec33894fbf8b5db3a447090c56fd24dac0553b514b1367514b4eac8aeba64ad924938fe16c2a1327b429ec18f99a704c610186332181c12ffa2afecfb0c219c30ce6c24d3b6d368b66e8a6cfe81caf654da2ea786aae106f2736424fd45b471b2ee6dfc0adbc79c946a1dde97608b7ff3abfe9a0cecfeae88e9d05fd9226575786227375db51f011f09b6084e57f736472fddd8196da2b470e695a8cc88614eaad0e97a7eef5726bdbcc1f7a1f9154128ca4c78193c9b601289817e9212cb32415cf8a11a747c5867721d64cfcc4f048bf014911d676320113ea49e35eb5377d4465db55f7fa58006f02a2697c13353113b7ee5940397410a875a77a05c50a5b4688c5a93aec4abfc12b83af63fccaa1fa34ba9eccce2675516ebed8b16812183ae6937b3928f0d0758099d17bb36108a6cf4634d71ab778c6470fdb771c67a88dcd03c7f0c628f74428f33e0301a0a1f48252dc2b6d1cc0df111915cca740e1b7202872408a27da8116dfe3c7b785041b9aeeb0f3f675d7136dd79ff5726d7539672f2788494d1364e5137df5feee514f0f6200b9a73f4d35f393fa301772054f679e1b344d10fe82a85ad7c6c6e783c2fa2c119a310ac455c6f8d038a00ac9c9ad3acf12809e3f6b853e02c43746e998dfcd49f59e4486b7c5b3f192dbfbd5869e966b9aa9422909457184675e233ada871eaea5b976462229e143d764e273dcacc028a2cbb10ca1eeaaa1a81243951b8375b025f60373b9b82d5961c281d5933c65b4649de691c4cdf38066a8c01c1dd7f171ff000a3a98d1f70d1c0fc2aeebf5309226a6e587cd109951cbc4e404196030553ed261c11e630767e3c7943ed5365ada44a1c854bc8a50049e5ca13072f06c8392310d2d67afb8a90d6493c2b0f10bb293b26cfae59a6dea4a3b08bf099598a67efacdc9d838a3313bac8d8ebc4a5cc24e4200356d38695d2dd22d57ed94975023398b99e871795669b073fe283d107aee8f30d4ae9fc7f2061d8f4c1b2f60743d7e9da308936979711121d037dd1c2f94c5258a3501cd0322169c02789527d59dc85354f4395616e7d9cf4d1c8ac34d3f6964e616d4e0f79de2973efa5427b69e5c8f6cfe96e6d7dcbf6fc74be69723083f6c5b9d9ce61682220d80ca9921c298ddd776c8bc1c1f3f2e4122e17baae96870c0685648176d850b42091ac5e915d1db207d2de6fb0507dfdb3543c42c5e515f50c48af85b09d132d901d3bfde871919e63881657b6ce927aec3b84f9a30704558af99ca4ca3ae2b6896c199516f000ec2b1823f7ec65ccefcf4d0e70041c53bf00575535fb5836ae99f3526087cb0825cceee1d356c858e9b2b219040b08bfbc08e01f4ecb4f1d12246dd50a64309b0d5a8d5d61c25563db8386ad381691023d057122876412799ce49f6666bd86bd04e52927f17f356cea3f44b0fef67b53aec0a90f48c358647f3c9ed2c8766049e45ea5c3fa574571cc34a3b4c78bad24e0b4a1b8ae355b66abfd6225ba54787cf0cd40648e9d45f6124afb30a78934ff7facc94a19fc1b03f291ab33e7cbaff718159f5370a630a31ddaaa6b4c0b976016b531429808fa147dab03f134e838010ed828a3a3f78c3ade24764b7fa4a8e03b5f1485eee5af1de6aa685c463d12adfeded3462f97ed2cfb0ca5b4261b554a5d47290c6e2004277e38f4418fcb9950f85f6327012b0acf74e1c4fb5513e2a2d89bc9f3a86be348a19feb76969aad260cc91f7a8649e83ae6e1a7ec2610f12bb25a06e96565073a418173f3455097b43ad7ee93de8b0d5f118974755016cee81672febad0e12d3808fc0922e3c47619a3c6a89fc74c66673d50ca558d241523681f3e20f6a262ad77bc24e93a16dea01ceaee8c9b3c7643a8adc023270b6d3ac42bf044687b5d50415922e7c28a36db4e93a7ae3a767cb542dab55ad6bb0539825b6d00be94e3c78d340a86d9e5c7d5394937486ee2bb39c631d76b3aa7128561cb56abe7c5dcd1bdcb5c95ba9cad843967125de6b33d1e4b417aecd5f9e65586c071175900702e3477723b25ac8da30b0d72a42ac68c1d7eed99dff09cbd3133d4a2f3194a9817bb7043cfe1bf1413be6334a86c102aff934d3fbccc52feda27133a59619173220342ad3ee5e44edb6dcabac382b99c2f950da6975afb98bc5116140468963e8338ce02001dc1b18b279cd26c716e81e506b8f4366edf537746a6d9eb95dfe54f9045de135c10144745a906f8e65758f496df8d24b77f568833b25e1fc987d0df5dcd7690d6004fbedf82ab52253af016034ba9310f7600fccdf1fb9538b52732a3ac5ebb80cfc379c2333549b86d057228cd526d7887a549ba9653d2fbcb235f5b6d0aba0a00c1a6b263d68e15f678325001b96edd59e42087110d94c7e9681366ca0e24805a95fc2948a70ed88824ce3f96f2dd54a6deac7368cdbd9061977039059e05da6f872459f5cc00a9133edc86f158864b27d515c4de8d0c04de06c94e7caf6ef06a8d1af40c1de07f0075ede4ac7e80d932c11a5a41afe36e933e80a78bec9035c1fe7a106fa3d80d135c21531755a82dfad66cbee59fcfa380764f69ece585854b18cecb636946ad2af2b88afca8cbd4d44e5a9c1b3becf83377818db0cfac957ff386d42696e3f9950342aff616b1b7ca772289bbedce33b989dbbe2f2d7fc0423eec65bf4ab546eac0eb9d40df90d44c7c87f7fc857f063cc3a680edd3c358f98574ee364d60062dfec1d1a9cd41913f83c8b8d116fe9283cdf39e1a112625893b97c872a27c22db4ef82dcdb3834eac32d4448458767311dfaf246fcbe93cf9faa16875ce6628a22e125c8f7a1e31517099be2a9d4c5dd02f78c0b6609809f9e601759e8b721b11e4b9f04c43c6c60de1c5416a9731198f65babde2985cd938599d1e3e2f13ac0dd9836eed9d0891f160630c5ad9df0025d5eed1884df490127e117efe051937ca9f139039280d1f63e23682261247bb9163fafa8e1b1c477f259cab2439d7c313922c8f79a7cf7d90f38ea1e52c964b853da16664abc3e1156576ce86e262b82f7cc4eb29d4cadff4753cda9ef10c0a1f799ed60247eb17376aee17b90d3dbcf2496f4c3ea6cd0c9244f478066992e924894acfbba2d31d542f26c76cc42b0c980a765ce3484e0803f6806e4709370270ba630166110905dfe8463540b5fa799ed0d037414bba0f44151dd30749b6cc619c7663a140d4242fd6014f1cef8565ad7daa973853785c3781b2a08c6f1bd6da0decd368a82fba6659dac04654eb62fe19a8b201c97d385baccbdd716b6f19813b87eed680dbd0b584bdb33fbebc563a6d459c6ded9fa7dd1e6fb6b9b93c2dad739ad869f0101404cd130f66ff9d331a570de0ac1b5bb9b6fca9924264d7d43cbf91e3d18a2f472a3e56a1b4ed43118e1c1782ff72f7e1ee0b7cf71fb8570254ddef4e7bc736dde8657491ca54d5d87cdc000c4e917d517e4d2bf4c67b0e040832e8b78e6ca066e32d3e502433637b436a616a6e83b502d90bbdd23867580f2112260908d2f6ae7203dc3fb1669818f58b6b7ad7cdc662724c26cf823ebc7b4474ef186af8c6742918ad559b44783c8ad361f8993d9a78b4ef1c98c38796835f89a8d8026301ef5c7ac5f4a60515c6e16c7875902eae35e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
