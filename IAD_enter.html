<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2de5a146a4d68cab2591557e05d4f79cf1967d969af2ef52276619bceb0ed9d1de6a020f5a5536a33795a721c74b5a574845a50b7e61421f8650f1717f097ebefba257ee1b4f54b7171fe8d909a6b4eba8e09a89ce877bd6015d3150c60b1f23f68af0acb10099c9a38100783c66057a8422bda1188cfcc6e0523ea069d2530ffb7e79113b91a9c03ff8add233fad76c0944458c34d6de929016404595ed033b1c94c3ad77a3039f868c657f55149dab7d69cd552e9220ed521ef5059a2475719287cee825014f5eeb57c6551532d9886b48c11cbf533afbf9cb9da60302c9e63fcf9f024a0c76124c78365c9620262f2f18b87818874a939dadc536670cef36768999b37b4d36a30fed1a17dd2463a5550e54c1d89f97a08e34e118b28f35a9f1b5d4c931d280bd6a8b0ee76ec1642dbef5e47aef1376701c9bf87e406e04e5620c2ddfbcb064bda6360b3ff1b8d99edb325e50e3ece75dffc937877b8116249312e2843a6ff26d899a55552ceea734cda8b6f64ac46437a648dff8e0ffd302e9409d7080967ac3b9608cf09a725ee48dce8b2e158cd01131f1e20e4586cfda9425b0c383919b1be13602c95a087b20f022f5833b8b1d04b7acaff24a78e158656690263ace8941169ba490f718f17e91ba36b3a0b3fe7264749e26c784d015bc74200e5d4f3a8c0359a85aa940f4b4dd526bd54f325baee05c74f28792eaab12e0f20765c49c983b1e3d7819931edb599a49bc2b07e3708352348d108960dc6cec8bf693368273b374d3ace595700ead6163e5c8ac7fd5b06b9afd64417ee2fd4b10152b3e7a7fe28505a24feac53e872e815e3f3224ee4c1259492751ae65e303ad76d1f37490ea01959614fcb5eb3c514ca6131862c85dd7180f6e78547f18943fcb93693d5433b0633cee18ac8fc1966e186a317f1b0fcb8c13869dd82e7d497625b5e8a16593d9749c61aad33fd56cfb0c5d7aa76b1fbdd49d16f3cca9e125c8b011dcebae1a61ed85f27bbe4b1b0e2b1f2d6fc9e489e827092061fb65e67c908e0700d75568f736f704a3b1337d4810c3a17e14973209b149eaff4a9cde258795430ff0d3581b94366eefbdfc833a4617b01691aab1d3db4ba36b7183a508b435236808976330227863a532b1a06733d181db414f22dd116c26c2024b8cc18f018553db45e388ab5cfd759d97e7035729ae19ec329609cdee3ee4cdf316f2a2d58a98de53c7edaf9fc37f3553c646dce98040d52eeb97420fbe59c8ba9e5fcfacdc7a37be958fa36ba433a4f0e7ce707bd78f60b38b31a81139c0b7ca4b494a06c4ab8c97e188e523dffefda47be982573fff45516c5b721124e4d4a02a66e79a9e0cf2cafe27105cb9ac478b9cdbd1ca3c9a7c94b95a2bb092d25e44afb577604ea722059861fba6d3992a37e445ceb898bb048692bae57a6246377364992ef5893c0c03b0db29816453b383a62175e46647e42a5706dc2d583b669fc8e8ae072ffb5618c09796221b38fba5f60fce37d47b13e9f95c39073a27111af39c8b8acbc131b9c20bad81fcdd54c8e7307ebb84789498b005ab3ae0955bf1d67baed11f79594f4561e5cc9f2fd9aaa5e1a132ee13de6700e12115c99c5034bc32b666b2d08c0b2ee2ca14a845973847e86e291318c1192b818f12731aef6befbec6a1324aa757bda81654dd69dfcb78a00462c31639e8cf6400dbd924331eb673a49545192fe72f9c0021025bf46c96d88ee67c1038959bd13f85941c98fab3b425b53119f070d170f81815c21637747fa17d2675d3734cfcc211709ecf7567e3656ef488ac4601be978034b7a09ba35c6c63190187cd8aef33474e76770e1b898d66fa4668469501abcd68b3f5d555a8609d930f856aed5df6a48755fee9cdb3f9b2c88b14ebc94c45b2de924e3e36da5496d6ebc7a727994f42142b05dfc8073bcd01cfee09215ec51c51eae86001064de95da26d168c962598702d7e48a3133988154bebdd3554a0f3d21be19e9bb88693150039e3891c71cffa7fc681f17d19564a3092e950394fe3a8d4ba57f25ec7b57238f1af7a6c49d2292608575bc6835f14b83f665a4d99cac2606120ded03f832d8f8ee7c68456249c41dc1444c1d67997ca97aa422870f1173f48bc4bde914c1f2ff6795ba2e63212cc37cb64ffe73b426df3b21ebec3314015c54ff003ef4536a19f0f2a3cc9ddc49e951469b11e93fcb9014c0fe82218597429479b189afa49ff9ed262fb5a0b7351e3c2bfb230ebbd69aef96690481efce8c263b383ce5e608b600311936a0429e0a1e0e7e71f84fd213a720c1049331261c1d66da18279acd57e2d8ed1f97757e70d497a8ebae8dae39023b975641beb69fdbbd69a3a26af2453a4167ed8beff054213d924ebb717bf78bf2ed32302013c91075df5ad3947cfd8d4f6630c943baf6ed64133577dea39ec9d89ee6380ef6da094e15bffa4d4ff956d809d864ada481dcf70180f0fc51cbe59476e9f3c8d03f8529e1fc77eeeb08014f28b5f07b4bf5225980ac2ebb80a39e87b6574d7a5ef94d54fb014c29928ab980af6c0cba5cef8cbcbb0cc006f6f1a07a285cb70f2d5084eec9b57d7293965d619618e066a795359eb9e369ff975562d5c0505990868cebd33dc00a856e4327ae6478648d278e87644d8b3f4c4daa5c514fa4dafee30ed9c4885f659447f7554b4bd518716623b2d0f9daf90c76ffbd462b8c6fe0c7174427910ab4a7bc790920507dd4ce56ef8943758fe25f73b3e0aa55611b75b85cd73955f630f53595cd47df1157057831bde58280c6b04e9cb72a9825cb334f4c9633cb8d201c683e157de55bba9fdd362a305be623d104ae32bd0b548bede82c2e45b1a08ae4ba49fbb9a6a43f7d24bf076a765ee3f2d1e2d6dfc50d4e2205c4b0c6aaf7edaacdd575aacf0589ae753aa889b63a8c7dfbb41fbf467f34a250e305b955f2c001b505c4b1f83e72390be7e1cae63036a83bdd57cd613f7ae9617725f13af359804c85a6a53be8535c6356fd01e1906dcbc0df3665e0e65ccb9297d413b78aace33d1cc0446d926a63cf9a24162cde831820c72e9489d3372628d9d3771d5d026affeb75a0e7ead5949d67f6541102d615867f694b041a43a5d1fb90b89c742896d0a2c12b6447b4c9b69753ca54a230946ecd9ffebeb864f7b6f26d89876a368862878d598048b212b1f2c806b2764632402c90f055bc765dc808e09e81a6009492313487c04793093feee8ffd3dcf62222200405ed7e0df2ee70ce98e4465701c1845f0b2172fd187369c666bebdff6b825fb2c267a9c7161ecfa704ea1bb298f0a443a7d3cdc0b371fe42ee7cebb310326120e4e19d38d1f7d0fc95af45f7940a3032924c2e4d67e02c897d2ac51303a5010822de4960142dfc47343729bf74833cea9074d1bd02713752a8a1ea35a15cc831a0d4220890763050fccca708389704b3ca775f7bcb58f2a250634943711d6bab01b6244a7db2d6c28ac10326e259ace56368d4396582d1b86a65cf98165f458c92b0a31aef7418267979f40751f428106e8244509befa649865fa48addf1d819e114a8f48eaadf467b64daedebff9aa53d829769bcb47884f8ea5dcdb031e53459429f7286fc79cc993c21a729f667c1d0292cae08a9c06898fb48331be88fef239e192367974af1f9a6472babecbafcfabdd3634fac0ef0380483e602dd11c07b16ae9f5830c3458daa83842c6a1ee4c2fb6157887fc95ed836c54ac2e8409ea58a3fe1ee1b6a272ff5f0e524587966f33eb5823e90e882ec802c6b098dcf92e25168bc526ca81956b9aa4175ca6b7d568a1f925488615afe6806bf1c3cdc43659eca547f51604cb232210bb9b1325f3fb94cd3f34b8a95a560cb938e95acf19a26d3ae3683eb9f2b358bbd16a89872b724be9f9b3443ab2a3c195c6b2e6d5204a321f67f830ff75188d92194346a2559c30bb4d18ef2e5aeeb722a95da96ca008429ab1bd39b9b3e88260f123a4d74912e8427d395c1bc9a3a1c8963a2f41bb1a59d2aa93109ed7342e50bc8a277055153ed4642fca628e7b9d128c0d607bab6f369c958cf61b847c1817508464c55ef3f3009661401b4eeca365ca1a0c8e61899de7547252dc98b596c71535c7b0d0975fc623fdfeb74b8b0475b21d4b1836e4b23d74ae212783037d5bc0282895879e02ed2074bf242e2fff46501f093eb6e4496c6844e487d10f5124f993e615ef633f0ec1f9492917239cf73261396f942934de22d83b7e0a688f8d0c73e822585d3d8fb2321e0f0e682dfbb90942d70267c404b07740511530c5d193ae4671d389a4e705286044a462641f22c8c8a8ce0d65e30faa43bc91a75c989c3bf38a1887bc456901adb96fbf67e1e035de50689ad014aeac95b8b0eacb2fdcaeceeb18e3da730fc8968251cec4138219d475858c2f5b34dd22e4a2c0d15b0fa3dd21b9d884f7bea705596e8cff6dd04af83d73bade57d153f4fa96296b9a46856a8af02f4e3680a0c7197f25614d93d137fa80ec42642b5cf941b02766e41af0333714a68fdeb8961fcc4b5915014b07a1270593a1038e4c11a54031f3dbba31f60e59295f0c2493d42e59d1a73863bfd16f8282b5182a29444e0dc6a4234bd59823ec55035a9770fe03adf705e98212e22c84bbbe92ec7127885fe139f7d3fb885fb787a57f79a8460417ee96e44dcab08115575ce06b20696c740ede49b5c0f93ed7ba4d8a758d1f39901d6d904236c7d632006c46b807a74d66ceb03450e8aee793cd85883e826aa81b04ddc13893422a30766836ea6c27d1fbc4113d47b12c038aee347eeb93ff127f49be23821b03fe28b2981c1dde62aea454b84cc39b9d34f040d8804821d5ca8b595248d353d9acc8644ac91d34a15c31d88165dc6c7a2dd636da8431513cd9d62e9c6d7e7f2468dbb7fcd7d0a5d2567e48b7bf8f58f3e095add1bbead2ddc4c9c68dc8d3df3e0cc0afe902c166c714ea003178053efe09860fb24c5d61da40725f34f93a4f7c2effbe3b03d8451f39821b171bdd918bd9a273cd766c614306122d7e8a91a38344b0a3e2f167eb35aebdf85a7085044d365f18aee387f1c19614a9c1e0ffb0272587c8bbc9426af56976fa1e1dc25d44efaca17d18e80c2222edbe1204bf09e7dbe808d348e604e39427e3c72101191a38ba7484d3a81f04338206e58961ef409e6a95566cfa4cd3b2073db1e3ca5f8e6c23bf3923140584f8d1a17943a5273679f69293734712376ae602c9f269060f073b00404aea39059a8b6060cc03e18785d4049f82f6204aa8a1a0550df5f60b1d4fe37578ab6f07bbcdf1ebad4038e66a929f1a992653a31e7b5cd3beb1d54848e34280fb2ca9072f1765120f848ca950bebe024518806fd167b567dec448efdca4edd34f81ac486c9e47f48e6a1cf7a83fda04cb5ba86a9fb3113118d86ad0bfb152fdbce1ef1c7a5a3db7c602aa3e5050f76e8e21fa7e35371c876aaa7b5a0b7ff0a0cacc5bf415022623ce9dc1668a297275d3934517b33ff7ea671bf76276472d3aa519ab471d43f911f3ef6e17499ba43cd3a401c5269ab96bec07d22c94663ad9e6db7c92a2e7a8e6d9ec1b9718fe672267166cc583e2521c7e047323f4cbf0ac7b5fac2ea039aa6a55ca0d1c72d0039d1da050e259bc2595d53a4994ac0854775d940d0cd700e49eeb154cc0c0d2f45d56a6db474795362ee70980469c67acfa4d76488874b3c6a196145176ff6e80460e1a9200ea9306f931e6a2a2ae6567550ec6e4f54458e226b85c0c2beebae3d7d54512750962575d5c39442f1e7e2ad956df592ca4373582f23bc1f98845c4119ad49ad52b8aaac830f7dc11cfeb30dccf24292ab58ef855c8328ea0dfb19cac80863ec25b9209cc950331e518ad1e554fd6abba44c843d7f9e0b5999eb78e5f850a32c5fd93da8d18d8880e9b7581f7c7fb8daaaa8838302635b37f2afa1b5250d8f0eca4eaadec475014971fe1d0ea235f81f4dab720b4b5d2692def59fc6b949ffbc61fc1f27d908679ca7c1ab2c3c2d339f9137a3227028f47776f38a4a25d51daccd7bd61e1636f5be4d7585b9aa0c5fa919e7f0b5be76c7b5d99dfd0ac51777c266731374f1341620faa540bafa28e8618c2360f03f6d4b7811a9aaa39a43d0e11cff29fd6d484050af544a3c172d76de0827ab6230557ed968ee706b9bbc391b570d27c7c7c36967e25f3e5c3becf2ef81cfb7035d56b774d761b13dad4e9e862e020d526c0332c36d18d31e1cec0c100147cacac391f334d68b2639237916515fb345cdf5c7aef8bb7aa2270ae1ed9227fdaf86f2a6f3ae93f34bcde8ab731150653c7d7af9309cb8c723a6c1f4e13cee274c1a704b03ccc1e58708007fdc51fdfd2c0d0b393644f11551e994ab27c6b18cb0fb085a2f63bb86b2871ce69bf74f23a58fcce179f2c6d185766aa73d4b4afe0b2faa17ea54749e0dd4036b70b5ff677b39f7aab0a8351c9c0ac1653072450da343fb58819061d1bddd87586de876e58cdb0e73b249236c298a3655636b61fc7b1f8d008677f78b4f71595d8e8a1da21a7952a15e57eb414222bc5da3b1282f688123fed5484aa78ecaf898c17d28cd6016ac4484b2471a0dce07bf00209d165641ebf1856b843c821e7683d948674d66514dfbe6d68bc1250abdc851c0cad5ac6bf2d63b81b2c75811b5af7f00970f4966cab14f14af610ee06bbb72fdc899c26b3dc7f5cc9ef3ba10e9a1c59aedea3fbfcab838751300b0e1e312e96e13b1d2d25e675d75367a4bd60076c348b4c9b97d2708b6c98cfb2b40445f73e75eb12695b98a792c519259a5cde8d4ed81bcd8462cd1e8b105b0c7ac8781a210f4cdb52afef20c7e09170159e90f21bc27df7f868e124d4f9040604d49fc2a875ac3b09268a8671e45ba1e6ec7a598a22a21241bf24163e0cf5c5b792c4c8e24e02567c1dfed4e1ed06e0974037c046b90250af07f4cccced449f528ee79d012dd2bcb5f90527b3acdb17f9f7caaaf7eb61534943c3c81364cd586c7924a710f2f37e19f7a4271273e08763cab298f212a49f3487dea2270e61310e1fd771e78dfe52301e53b1565a7d4bf0df2a8efc388419aea6d011b778d0766cc516f61b9c5a83d3de5162a06a819b0b0057b28c00a464cb07a9b73c69a230ff5ec63aa34e1eba03d38b65f84c89e030518b277dc2da12c7a1fde5313903a7c7fad6d7183ae2036dc0b01abf0cb6845b3817863433212ae98a20bad1d2a4f81f01da6cf6f56dd9791176d9c3501e9f0c9c2233fd4c8acb676e0e37a142d25d00157500d527d2a6c4463663716bd1b237f7703535cd239b9fe8973c36f3ca5e7cd80a6cd17f46e770a94ac8db3fea04636829f1b8782fc9fc84133447250cefd45146c5fec5ebecaaa5f694900e4ac814361ad43378e4a3e7fc3526e69e04152ac4f761489a4bd74f1b124b749a5e59c04b62360bdcd9f9bca6ff27a10bfec0dca1a226658b9a08823a2a24dacddba1409f419d207dfabcaa67429e79d09a6a0c926aeaa182a5ff1cc659fe329e67f85eaf926c8e205a9dd3b1b76f77daae0ecde90e2b2c3672f2149340013c79b9dd430a0f70fcb652ca804c261d68f622f570e495f3d1ed538d5d452caff5470347b801326e00889ac34370f18d27778eea5698623fa1afe921decd7f4bb23f396d686dfcaa54ad516010bcc7b21ab1336e69e922a72ecefdab9cd0d52584c7f46ed6e17a12edaa8875bb37b0268b8dbf5711e25ffbcb721011b8c57cc8bdf9fb02ba347d40a98d3bcff26248ccc548845af2e6d6a42d8eeab5c953d7b10d810060fe461e0af2de0b615a3768501017185f130478279840b4416e5d36ab505e8a53c8e08541ff92366cb2b8e5b0b354fec0df7c6c047311313e2971b2ef11cbd6d82b93dd5a7a533bcd1212e7d938758e5db1cd0643f67bad0395de8205eca854e543d8787f7d86a0dc82ff30279a550e8c424afbee56632ab5612b6e78f552e9f5b535e5b34357192d8de0f9ad5b0c1989eb92db41212b5ff4537a3a53e788c9046fc98ccd7a4c3dbfa93db5f5e7fd4b75aab59f44deaac768c47ac452cc5fb8fd055a68cf4179b5b1b2a4a231bf75e4b6a2511e925b3c17975d9022eb561786d6cf5915ba94500d0cc728b23623cd7ac66c51e037f7f392713cf53b79eae2d2c8d41c47803a8e0493c824735b745ed106f8ca64825cd35eca96cc594a4e5b9b719e4056a25e6694d7166766d0dfa2155c35fb0701b5bbe3fb8557ba95afd72a3fa20b8a9a14a228b7b6d443e4ebb739676b41982d4293c4cf5e393322f8a6e58dbd03aa2f6e77d959dfaa1a7f84ae47973090e55461d1c26743d9f100ec06ea28742212c294a184ddfe6ea574fed61bc8a17605edc27bf9455fe8894525eb7069ed62dfd2c9f913cf29ce4a72264f43ecefacfeb8882e6bdf427deb77d573a10296d5276aea55bb147f249228ffec563b64c2d49204cdb2559dfe38382294d5e13dca7c421a724b018f62b5c5feacdb14fa11d3f7d2da1f3aa2277e9d09921e3640056912ab002aa77c59404f247db381cc256f379bf9afa84c85e6f63326941197b39b00be9700e1f1c25e7ce57cdc4d81b9968c9f97c5b555b224501e25a828657ba26c4e89b42d178652075da0e04f19a55d47589efa5cf493defd54ad343987178ac953545027b17eeef730f14509779947dbcf068f0c7cdce7aa1572238fca5f70f68a2ed84c7b4dfa48c2456a11352cdd7fc8e6c93c8cf08ea28d73d480084699a4ba5e03b76f5260b7c701a290f35fe9e7740a635688f6c09c7ae0372af53cb189aa4b09f8be08c6c91532d077a831989a867aa1dda80f34a5c8cf3a6e8f281aef3bc0694c13dd95dd61d7736b43397228e8debb0e4e6a366f5d585dddb93772bc2bd816b5d327977c4988441ef13409bef64c2d6aa6f04980ac59f2bfbda8253cc42575a6d6b88dacedbeaadca00f4b34c97823398bc3d55fe5ed9230cc0988aed9b53742c5d3f1ee06a7c3a29fe8802ace3ce34d598fc745f5218de4a29c43143688bfae9b651d0042f08e18490bf54337eb22c780a7254cc579ca2eec0976cc18be310dbf1d2b01452520877dd1ad968cff0db06487a8179a5912ddbe534421ae3140e5e6cdec3125a83eaf291c0c416ae2e287cf3b61dfa64148994f23d94b56325a591cd98bb305858a9b72218ae4df3538788419435a295969133f710bd22b3b036aa528edb9ce72632b5d6671e4604e216a726d79fef85bbe1d40687598abbb7a1079ccb86ef97d3c7665567c06f07b24a048d76a297369a1a0cd3f063ebce1a82e12bb6c1640a8049cbdb7a08638fa6ce638d3fd46cc9629c43a6085e5c9ad23824fbe8110e6d09b47ad233bb55c602242822c6d6d3bd08820ac2840a0428174971ce09a08b1c0a44131063bce8241d8609f570b54af57bcbfe2be50fccfcb49e2a1de620a97189ce029631562a6b9ce0b3890c83eadd9ebcfdb498f63871d594cc81d4ba5bb2aace9563ec7c5f73977a9e863e9c7e00c716311e404f20f551305eb640eb14181f69083fbe38db2b998be5871c1a78ca6e789ca6e732c18b83a9998ff1460d2bcf7002c11bc206ccc790142705af53603d4453491ffe544b6e8a4df49d2d7b21f6c6f2c9797dd37ddf8667f83afec5cf71b098a137ab9b943688abe2258be31ab010db651d7bcbd5ae324d19740328678571f013827c5b7d09e24789f4de49ddab60f2a7c7f503aeb3c593103897c6c19ff94f8d4a585410f4ffce96c9f484f52e46c599458d8a67c5b22f308037a7e6cbc3dbaa4ad7a9597bfa6583ddf37143dfef0dbdb41567a5ace4e463691accee5fa3a0536a23b3908e16aae6e31362549dbd54682d24ecdeda93fa0d97283ddbcf1bcbdd4c0f31ca2bb943e63950161d318e932a13d007e6be615ea8b8829332a889eb95878cda1535cfe0077dfb5536597b06cb9e9e6c283b469f2d2432ff4e0f0dd19d12f3f9e5f13eb428d68f87ab24b0fa285fcba4c61cb76c18b84f1ad7a697c808b304fd9ba20f5b286fb487e484e7753d0e0f33f26085b0a493c1ac95fa39c1ec08d86898be2a7ac20a871d02dbf4e4116cee9356bc4b45c746831a18c332485fb6b42ae2b375bdfbb13d4ada353ce9d4a6fdb7a36e28187616539f24867474357a754af2d272db597ba4497a378068ab09c4ff92c2825339cf058181d6520ac2e34fafdfc36f9b5d44ba2a43062c1f3933385a58093201776af0a70aded6b04fa610f4b62441455b5b96e63159eb20351a58d12702d3db23fa8ed8ecb7d7cacb39f38bca9c3a69d3277bd887f0108cb2f7c1b99a826ac4cf7054321a9adb7b640c13225a23e9cb353eabdb0dea32c884ae590f8f6723c13f7bb703dd4ae2f70cb02efdce1d4d0f7ff002c952a12c7af53a2885177698e098f43505844c76aa3277c07d8aa04f4c6bc5fd3891b90f65766416e27d423be4f2c7f08b70a83b3127325bb46b242955c40f8edad30b37ae5b0050924550f421fa22076e293acd22308f048957398d8f0b35e5e5a3d07f488aaa247f5dc898bb0b51caf8c907c96ee4b4a2d00bebe9a971a00eed72d782e674eb2e0c07d22c696e85d49cef728c0e2de3f4de0262474c02a43edcee08dba716ae17a1a262b92ac6c2536f5feffd42c214f8635a8f9a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
