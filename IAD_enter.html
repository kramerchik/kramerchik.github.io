<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f7339cfe0a79af63aed10fef37a75de14105b5a695cf7a0dd02dbe9eb2bd78f762aef075d154321c345e7220800c376d42b04522f21df5d4bb3fb1e01e6cbc57c03b16fcf116dba476d18233456c3ca53e5573e19fdcb5879e5e20d4a5b3fb8c2e2f94e4fa6f88bf71d7f00816e3718bdcd8d0d9daa2b632542ae9cdf1610e2d207a077fea68ec97e5d0f30d867520cd00e288a942c0ac7fd41b1aa2a4f2a8677f9202f4a251367e9769fd6fc5cfc45df9ae6e14452f20c45745d0f80c18e83a7edc668289fec010c080d682b4ca3b0f6b79e72f15c4f226f1e5e7120aafb0828756feefe0808cf2eea8081556995f1bc2bd5e8423d30eb9d2bbbdcbe368a2b0ee6ae20b6ed72d599f67f0b896482a18c8c8d7b9a4b5150d8a6d728ca96413458e67e6e93decd8542980e559d66585e60c18b44e2c2edcc62c37f6641bd84a7f07d183a69a6ca418dd850d71791686a3ffd10ddd6e7be116fa59c235d43576f67f6158c0f50f2a54bd5b55a6869472c2d1900c910e136a693c619ad53937f35ab50d03e83c007512adfb55c1e776ff33e13891879f43e33d93eace65074ad032a8a21a65420a48866c08a68e22c9c8577e47e910b8bf3093ebc1e1ff12f9142398a8480fcc298ef30d5893da9f0a6ee5315bd58fa352362a7f857ec742c0d01f812a69b188060d83fd345b2d862eac58439969c6008466adf805de8b392d120552b88eb64a08e26bd3820a31efa8a395b89b1fc5dfc030ed922c7313a1486494d3f9f87808d6b3397fa5af2c3b81f109e1ce69ae1907b8eca1e9335483aaa17d8349e4b9c51d9c9281cbf81641cb6307711510b21696b0105d6abc645bbff921f33d52d1c76fb2ccb286672c30196e7e589fefb9b81d68fd4020545eaa8dbc6ffe62b82e0304e9f0cc336da3477be7add31303fd04db6bbce4fcca162147f59c3117c120a6e573197fd1af9d16907de915ca52f3e056cbc71915ad25092a7a48eae9c4113f48788d793d67d43bc81b3c218b87f7585225b15c18f1f0eb122a93fda91086b94f9e87a0d3f98f884aba14c4aa07cd2195f1e0db3db0e75f50923f324f5aabbe874a71636f970e3ef824357a97d5375a6a162c1e6b492e595efdb4543298f932f72e8adb7bec689439a13cdf8cebc77f47d46c7d3756435cd2b532f05d03d4239b6d9fdfc4e03bf8263cff6b153257dcc5c6a6253dd56c617a596a9eb0ef3e5cf871f00be8a48877d331164e8f7003efbd21fb868cd229e21e0c05e00ae0efa2c6c3580744e0540ca555dd8c93096a5101215e0aba504729f801d011104b3dfdee1f6f75a15a42eb9e4893b61ed51bb11d6d287834c35b2042d5c99025415306a99979b922cc9e3647edf28b7caa283a04f82073ee3c22ee59f9c9734e5c1f9b71f3bb8df942063395171e57a290510d2090474e412e52469cb560de1c646e159388a72b04bb506c2ddb75c09612d254f4a950613a132277a2092e243f4f7eba4c0478350569fd7d435dc487c2dffb6090d26094f23bf9b3904e0a6e952cdcecf7622b54744411e497ab15fa0c669d4b4afb7f404d1d59538720ba51eab07a7c281e3185f5485f2b347ef906386c5c94776d74b2b49272792f053b422e9ce4fb65e75b8cd011a34aec79e79d231904128b77bb4d506b79842d3e97bddea076c1303cfc59d47035248f45407764af05f8b885f3202e6f0db5e8f47fc4278e7a22f1cd1ec126157aeac0e45e65c9b315ab7c386b3b42977d40139ff1f235f8c244965b8576f6db18c799420b91c0cbbedc643696fdcb75f4104448d8d0aa49f55d3bd3c0347a630b78a64a8462a9075c7528c315e985d3d3079aad0b452d3524586bcb779accbbef6c2ddb2b408fe37d58bf10badee5425c4b798aca7a372d59be9b464a51d442fc1c235c9cacffa942bdd137914bb0d750cb012c1249acddc9e2dec7cfa86dc04a3b4442e93fbeb65a6c4002c86897e0ce144002747fe04d9c7b45beb9209234ec37ac3dd47819e5c3ed1354dc3ec7b88bba3d0c14d340877e2a468b80c214b85d21088350bcbf689079f54575bb3b6e64eca7dccfc5a88b0fa64b6c30ec80c53566e85bc1beb60aaaaed29b0da59efaffecb4a62a196aab72664d032ca0a332371fd46a94e263302f01bc4b57e97b3b9f56bf859a76cc70fc6df340e5a200a2d5678c5101ff07fa7a88e2cf8b70f9dc65a4624fe2b04881e9e680d2e4307190a455de7b3116dc3506fb468c8e50fd96f45fef7ee405844df7d76028921f517bc12dde78ab6692fdeb30bfc99ebd0753e4b07e25d1a3341518e70886a61303a43dca846f806161aa7a800f15e42520602334202b448462c8caf0d1792a63f3eb90b8611f6663530d12b3c224e06cc7d80f2f851b99e744183e21633bc2d2701056f0314a30bd21905d74d4ea5936e7f10c8fb0b2a9dd6b62048e01b71c16b7196cf43f65ed34a67951f6cac592af35511db00be6eedb0986e7d8d86613e1bd8c344d01d833a1b0dd2591eed14f151c474b1434f54f69a8983b277c99d938acf193142101c54cc239eba6eb504159ba7469cfd018537907582014d5e900b4a728c236598982ae34c533214dfc6b1b9721642dda0d8aff67823429552fa07c57ec6c9cab4ae8b342b681f3aa134b07b1158cd8231f7ccef40bc7e209c2246696ddd482a59e3308ea3d4a5f27d9781fb1d0443e7c38612ebf421003ddeb6bfecb2e915a5d1ef45c0f76ce47a1b22b3bf389b22cf1fcc6da7af9c8c67d7f15fbbadd8958dd76b50a154cee2a8da577ba441edec3f12352cba1ccd462f2727cc0214a5b821858cd5ada957c6e299784ef96a1a99ac2825943b00df3fdb116b3f70b63efa29d5fef223b1d5b06c68bd44f5c94d2fa2d0af1a2d205f524537200a1505f99eed7b6b035bbbc6a763e44938f877601926cc5f349005f85b88ad8c2028eeaed593c639ace4281882e986712e35897d3882de6ebee011c657090073c1d6627f4db856c522ca48600007cc4fb40e3c5692b89d8e444d1ec02cc438f8189b2abb77026dea0f2b4037ce7db79980c01eb098b30738111dca2186ee1e8f98943cd990d6915c34cb55e6b455c3e8de15cb6d43440de03d71c173383be47474d0bbcc71f64baabb81d46204aebd6c3baa23652e55a0f49285fc609415b5a600afa2696d1f47259908cd9a89c052ab4970a954dc7e912d827c50a9f3f628009c5d9d07a25ce53b01bfa83e311cc5961c4900dc6679ec2e25420540906ce17d0522e399b3e8f841d73205aa4e7dcb344f2cda5962e2173ef6a8e7715a0b3ed3fc679a2bcdee3e03d31d8765833723cf1e4c190fb413eb6687ee3244a4fb909143b8340ead9a0334f9b49e4ad34ffc31d170784d02d8de910200a9bb8999b0610593639b6cac8f7fed9dbf985a004076161563bd7ac040aa58a83f55369c06d65f11450e08a4cd1f206031224b711719cd8f2412dfca94990f897a5be3ded20072c84b72ec12d696395e990480975a13f05f53e6039071864ccd04fe9df7c56247149aad43eed899ed89d6459932ed3f7f1a2cffb05e4c8031b4ff8687283bffeb9c9bfd9ac9544e614df897f45f71af08b764002b8c5f92f9635f1e668454296ff6232011dd6da95084f244dac9b51587d3d326b252c70b00525888d851d787e1403813c3a8a86a0d25d17ad3f59469ef183d5eaaf802b725fe43fbb9d35f82b3c8d1e015b3d8f573cd8646378900b0ad086b74d6e32f34cc68558627f016e042a45752c7cc0b128b8a89575a8bc19bd82f4ce8ea7cf95453f2318c41ebdcb78ccda4e6821bf6122f5b657fb086ddc49b7f1c130aacbaf66d5c2b393765e8b2229bf25e40ec789716f9d9bd60a4ebfc31a61bd4da9fc5827038a56a520eee00f159e057ff8e86f46151c232fedf4d6e47e72c51218a0012b2e66b5403b1773cebbfa14b6559f62ceb3cdaa8a24489a7f236bf4a4e28741f0742ed0d8bec7cad06b39fbf2711abfe383853eea2e37057372eebfa260269cc9f58de1a348883f62478660738842adb16514a37b5f02b89793b88847b9e4712f47d0fa5cf726f195df4d20b11720df41e17c4539fae45b85efd3ef6625ab604a4e36af55e2f46990131a7e4ab53d44cddc4583b51f04cc7e95c7d7bc98580636a3a154edcced60186e6e77d3419c4d46fa5fd3f46af740b439fd595e810b489e9ae8ef237867939e25d524b90fa85136b8991f04fb8b166368188a252eec9464b5bb3c629b404487983c52022e5f1e7666eacbce4d6119cc2291ef70c059a2b845c0e8eaf70473f5505e79332e05f0717b84845672a674caf7160450430496ab91f48841650b957a579b870c22815a7c253caf74dc9740951a399d788e80acf97d7e595ccec5cef1f873e1f370704dce8cac0f83bb7f34c05c97f0c63c739097d6f3f35f00bf580dd87d9816839ee3936dd27d09ae36afa8e97ae99e86532f3cc405b9b55ecffaa39d8c9845a35046f88d3ab0036ed49fe553e923b7852bd13d0179e4e9b274c2731a814b80ef488471095c0abf66578f5d654b7aebea287f85f326c289cf0d627b8dd037a8668fcc42e0762ba31ef43cfaa2bf3d61288e6c67594f65846748869d8d30e5001ad664fe43d579ed60c37bb7777e017e8b9eab3709de9ec855f8d5076f5d4efa5190ea0de75f01a9dc15366f8ec0135ee6486846269ffe1a5020a3919ced637bd41ae31d35d114bff4472f8e5ac759770e7d870e0af50ccbd2ebf41c8f30e06b98b64a56267b906692caa7e4f45379331197bea666c0515c33e38b3f6326031770c1604fb18d6a210a2407ebf31e483c29dd588ec9ce9c07ebfcb261eb6e0235d0da050aa77e6534ba7c764d734021d5ced34d72d240294d8bd110f5b6b24c039475bb7546e6db76244157786aa6c99f60fc84d38f5671119d76f6db3652b04b2e943344e81a0892a5f31194cf558237c85712388654a9f2caa31a338de79cb7da7bdec75ea9a154379d3b16d381d86db189f0830bb378259290ac294da781799ed1261c2baf14530a008ba70023a5cd625d80f89db2bbe6c2b8795be545c6f9eef06fef0c79685cfcc5aa069fc5eb33526b4ea9b75e4f417ede47275d224278eb051fa753ca9916409430a7e27439eff0bbe8b0a8377b0819acaf4ced14f6d886369d772436fd224fc6d4862503994f1bc992c9c5a8ef01537207d5802b5d5e8b4e00ddf248849fdfb1be62700b8e56f71e2da4ee74267b3b2b6e26deb518ffe3bd35564351d946e4608629cb01a05c1806a8c22e12d955dd8b085a18fdb0b1905c8d91dd203f0510a8cfefa1c291bdc7187d5aac6bbf6781e08e7752b7fddf4724d509c15eeb7897de16955f7f460f570ca066db6981cb300a3e860ae2dda8546dc613fb45e4fceb3b9b353babed32c5adaf609df7efc6194aca449871d27c947d61f507ef60d194905c972ed7daa41ee77d24d852a9fccd4d5fc0b3547f4f60c786f5fc489f91e8c9ea4d725c45ea807a2cc48c6b7d7d7f8a35be9e32deeb4596466e8bb676333c270143e7886a50ac236858a903f8df6b60c0e36b1a94f608cafc0eb7ef60d9f67893676bb707b3e26b3ba0fc6171e315b13add60c5129481b889c5c759108f9a80771a49754783bf317f649a74605090187cf8d0805adbe4a47b731f927935aa57a0b62302f538bf2519b4ab89c3b93dfa8c9f74872b0984802377d9c7ad18240f96e0211a481eea4da2ff245e3764c90a25eab4ab2b773239e5350111b0e9ac77ae91e785d6b084761243dc7910cfa237bad8cb8e102ada7df9ab0dfa3753e8847b5ba96714c2fa4bda561a5d590dd0fe3d70783d310151157782cd88dbeb9bdf8a9f334823af4072263ea60b90b489a94e6e2d4b56a534cd1c9499da14d2aa49709c705d0bf7f7de29920a53295cb1bf4d36d3617d297eb3dee63cb09b44c97a1788238d4c7514cbd8a7a5b47df876b0b0f166b71d66c59dd1907ae9b1327266d6c87493247a2c7b6f61c4089265d6cb417d5d24269c10ff2306b233f8254091e64295d27b6c37e414d81e71e17f0f31183bda01032e21c6b99a66e92e4df698a145823b652e4c3d21d5093666c67d610a64d915fdfd0b3a5a62059760da28d7333205dc6e1a17aef612fc99e960656cf637910705f66d361749d3fa658e17ad47e89a5df27e8a426e735afc69842f9bffc925f574d8243c900f52cc6922e69261c589b1ed0b51c9751b4c0ee6cb7bb133eb5d7ea52cadb01d44418ff8d8d9f210cace993d99f075b99aae21f83f6ccec41d0b71d8eada3ebc546f673ecd7c468864707939e91a0e514515918039339079163f8c0d0f2a64939bb77b10fadeaddb586c2fbb3a7d18915f2dc8b8b3f16522d80ed4401aac24d9ae2eb95e8db085709c8725bb4c9838e9c2a193695b9276368fb110079aeb70dc2705e42b3834e85d14735b78af9709cfdbd41fdf9684c85a9bf04d97633cbb6ba106db26c195030190f477a7f5aa45e1b12e834778c758af96130a335983e6853853ab0cd1047609e4b30c100e45d3e5f215c486e7ecee7f0f51ac37711a58a2be3793d21610779c598d67da899abc4316fed35afd531bce1656b7b46230d8d343eb3fc76db679549881f572b8cea85aee0d17df84f7eca4a593721b8b274794692f8442c79de550424bccca7326e57f9970dbbb19c5ec59af66ac8034f0d6443cb642721bc3355cb8ccb73ff1dd58baf9c87d78523b132d33588003389e19a9284e525e5dbdbc00c55bdaa6e7e031557008566315819b42e6ab688de09d7d728e999e2a34e2cf58a84fa18db68daf0700f275ca6a8c70fe4d88e254d42855c2eb1b88a69445b7e33b4d6129eb4f0ff03356c88b636b014125ab922d10991f972d198c2d41339a8aeb0bd91d2ff9b95fb98336936ed7ff841b65d67052873ad99e8a7a135fb3711bcff4f5dfc20ee1453d2fe81ab283bb738fc766e96c0ffae2a756d5c333b36aff920a1c45b842253a059a19f112c724483c246fa297e1e9c30611966129894a573a0ff120e5aba3b0f272f956747a946cf44b5bb2f1bdc5b434fbe84f945a7aece77835765912a55b817bdfaa25f266f2b737d667129419c2f252350dee79fcea8ba581915dccea9e973e52b680ff8708d28543b0839f0e44072ea25516e3c5f0d8241cd4af95be8c098fba778750c55088f89da3bedf1787e3a42883c430cce9e9832a99797cb7b11f8fa7792c2b44880977b721428eddfd16417bc925b63c9cedc05bfc428dc5796ec6d346bf5d1e8d26a40a2ca869321e436b79da6911e8e1af2ea17f7c3c3326fedac237ef56ff9ff30bb5daaab9d3bc85e9a75037c62cfea17ff6b400c64a7b4530be3b22f1cdd17c739c474e404cfdedb8f7fd357773b3430e6567a3f036bee40b50ef86a4b2f7f465289aa75a267edf0bd7883691ba7dfe8e65f44376491f3062f1afcc00be0d09c7d74880af6a7b249d06e495f76665f6064b777500dfcb5386b162b0f2358b633e835ceedcfa93dda2b11ef81d57897098e9cf1a022bf50858642b17cfab5793bf2f71bb84663616a3c399518d3ac98e384e548576b2e49ebbbe6ea5bbbee0d3251b3bd3438d43498e4f37bd99454b971fa203c0f4818dcd175077a564571c750a581a254166bd98895d56c8029f55c3fae36c310137a9a00837851019a08f1b370c1572f8a1bb661d3ae54bfb1643f676a846fe8f80c9eca7ed73411ddb46e078620752088b08bf09ff8c8cbf99c8c7db18c41b437fac42754e408258feb20ecb82331c2d48df38ebe2a3ed0484a4d735117a69a1aa1b64c7a27f309048b21f2fc6c8ee769af1513ab63e37c3785185f0008799fa9179345b0e07f1d235f44b2e1f907e1e807274ecb18a4b83a122252f17c6c5c515e6372803fd1d2d4a95c1149ad3f3b2d5050ada6cb88a74a6339a45011c0043aee7343e2b4c7e67c58791e72b5876e7fcb1e5e1759b04d0e8ef1d36fecf374e9b5d548e4eff391552937dbc28387052c5a3abc353f11c2fa831465881126264ae9db1edf94487af02abad6756728e3607e0f9a1619a801f2aac1e78b60a50b9152df757aea8e73ca78027d5675f1268aa5a91a621224578f7c21cbbfe9062780ee55574941742e25a1efcfa2462e3ebefa6fcb3e641a5bd9476988e58715a83a8f433232c59cf42fe50bbfd56408ec4a350c3218b7fb65f56062472a75b52f00ba663fbc18522f09a9bf4f95ba209a06d3f104f3f91ab15d03ef476621399d879960699923e83ec0cce35a5c8d2e99010cf98e8b629f8f7cd1c1560e3470db93d0a0f0b9440ea1d62c09bd02a838d0b01d19e78dae0f96f1bab3ff16d4623a2ab8ba3edcb49d0a5bca9ed0379c15e260fa0bda36a560c05801bf5272739816f4646b7f0efd4a5022ba4933c258ecd23ae8e4b9374b4b958acaefdf3f87514efd6ddbd4f5a89c3b9ec211f83ffa25b342e0849ec42686f9f961ed49a38d223c09a130a2b74c1c09c25beccabefcb675de1d978f8cb8f969aed0af44b67c1ba91c1ccace09251f5c4eb515dc40b300d0b2f4a2ee769487acd1401ac8b8465711d0c5a60ee52428b8a284888fb835bc7e89aa97f762405af354a450df74b78bbb4e7c0c4fb28de65ccd0c593150c7d6f2151f8ba9bc6a033e2ecac0bb7af77d764e8e8c5642e3f382f0f45f5fe99fab9346b2315510f706c86b43b46c60533ff5ae722af995ccbc946df69b8202356227a4c75b919d17626f80c8b0ab5db5d414a7898a00b513eb6a838bf61392df8bf65b974a63fd63c7fbb5218d818bf75d33b1072788706b205df08e991d5b4c6ca536b5c0a51a1a2031330708a83f3133913470138bb239bac6f65ae18a479a2571f97317676df98c0a34c47d894b34bcd513086dd8e2ed26a1f3bba53abaa32cfbf61f8e3441aa398ba01f4bb4d8d7db30ceade278f4eafdeced288e23419b42881da11fa52dd23f90ec7038c1d3c0cdb235dbf67948d6bd57d17395b8bd5ec87499c6b8624141f36c3020dc3bf8d99d027080232151eb75cafb9a75423da387802f68a95eeb5febd0025753cef87a19fb6b7aced16c8be7fe6ea0f35e0a09cfefbc637d89ea54b101979792a581f9b512d04b1fe0a0057e138db7815b9b9ada1f233417f0475df8628eb85d863eaaaf89ecbe61cead926ddb325a2023bbf1626d68b3f73b2d38e47816483e79143d3f1a1c7b27501ea43d1829feb125c179dbab562bfe799bf8d7ff855b80178b28e46885e25c79ef4d2b4897e5536af31bbab91eb01a85d2088283b8e6814e4a9fd894bcf4f82c74aa702535ede3c4b6c97e5fa3a2b9a4abbcce4b74202213760d7ede1f479c6372af4f8fc4ec19e98b3d82089f06d6483911f5f772348d8d499f791c5adcd66d13e1b2f0afb4c41c04dd8abc54535b9155757cdb7e58ff38f2b9f3fe02b32e03fa483977a139d2e0d2187a6861c891e329f928c929328265687640d21cb2f6e77f868c538a6245731cbca8eaeb213c7d8474ee68367f990b25e67332be20969115094de8e1dfb5ec889a2d9b95023147255460b25a4cdb6b9f4f137431450ef8244fb5f46df08be5c2c723d39cb2670a5a2776f63788f07b3322f54b2810be5158a492ee2a0ca4b7968fb302f029a695d4123821d62de09063c29e16d6331d5b2036c93526f14d193ad2c3c81497b894bc8c984f73237c5e8305a6d2b6fd4e099847bf23dfa35e7c805df275416d6e4526b44c8699ef86c2d86b951d6052bf77c1a2df7100b4fb9032e1ad299772f39370dc37131610e3d4d7a8cf6144224a73f90048622adefa2569b54983e5f75c2c01ec06ee04aa62bf4d7c4df2072991f9c0e0ad3f178bf9314a679860e2dcad36001f5fb70e1f1f2a60095be8379a408f25b162792dbcbf7a05aa086022bdab0772f93eec868dc1446d95bb32ddd71c9e5d70081780587703130a9121725fa9c9218953974a75223dfb95a1605645f6aa03cc68aebb607468538d1e632695c362774dd1499f725a79f9406c6dc8ef23efb8905031d933f866a4b7b6a3281da760331f7e569a5147490c4865b8abeb2fcf6dcb96f9978fe6f7e3539bdc4efba278ada180ff38fe3098491d5303f591b3553aec02ac9d793acce3b3e062329b46604c21c9dd887e4bd7e8c9f2c38a988bd27b883036ddb7e6a7b8e13256fd092dccce8f2547b29a9e5376cb5fac4f6578939cdf4c243646f5fd22e85ca2db94e0014d2bfb60b2c45f0b160a5c7882b7581015cdba02956b6420e0e971554a4c14d7a87c6f214845c8f095c03bd8c67f834c64ead81b0eff5f43e8386fdff6021efca14e27b09b61976a91aac5aca020032ebf63ea9335710e05f3c39bd087c053e328d1514705425f1c817fc301a7b9f888045a6ad0d1109db496c490845f216cf38ef1e68a434b8b7c9d7614e8c631ad0a63f7eb80654bd931b5c5d0b0b364f8bd627279b5cd1303bb950c50f8c9e382139865faa0c0bb89f2b19a376ab7a64b6882a12d9f6d7fa976f1859cbc4cb57e4c9f17fec900cd2fbc857b2d0919a6581c7c929606b62da4c5603a60c5bed25146ccbde008fe3aa37d88cb33f3078b3ed945133447a395e3aa9743e02191bf46c36664887bfa163211b76a6bc8cbe59864a35ea6c965cf9737ed5ec4f2cde81cdb6dab1da37ed72ea8f501d68dec75c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
