<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2df8a86c0a197de7012ddf40c28fa0749f16fa736a5254895c8fa85303ca4a44f8bea847b53f45e62dc674f30bebcc5746346eca0eabd61e1ca4cb6e486191be1d09617b46f4370d4a09774e54abc73e95c892e52e80e51e4c2706809f6477c4e2e2ffa64265e08465d732eb5a438374b2f15988dc2bac25ba5ff4930d99e37f07fc28bfc3ccb545db3499754440641c56b99ab53aef5371bccbaaa60ca9f0e86094081352b1ca1b04a4aa32e10bc2d26d775d56ca35b2bbf0a258c528f08aa7b086b36ad07f1abe5b4bd7a61dcf633324013ed3b2efdee5598055dd2a0e2796ceace545c2933a6b3d504f7634d00f875f7c9309b20c0b8c147189b3dcfebc16d13f872a5a3e829a86e8b9962111042cc293dd8236e904ca9036b20db1545c09de509af427154dc98cf1f39e1bd0c7d04fb523513bfa67acf40bcd7f21fc24c3e826ad5734166f8c3e57c495011331e84416e48cfd1dcd74fc4fcaeb6c987cdd68f591ff4dac2931435050e5054b2de51cdbb6a51b5b865b1e90d35273546b98dd39eb80ded4ee098f053f80c3c74cd877ce04d4b25b9d301b6210cd186cae1adaa0256cbbe92f612e050a0b74bc769c7b4b3f26386b9ad283bf46273243823c3c905b3ab6ab36f84ab091fce7a2c8fee0e68628cc3f0ac8d60abf1c7b529a460fff9bc919b2867e04cffdc43b589aea76a22ded5f6986b4ec028a75a0637fbad9834e58f8980c0f55296011dbfeae73d61b1e08f5a23903c399d5c4d41c397fe6fdb29714876900cbb42a1ef678a30539753f6487758d59ff5cd1bc2fb0440cc575519947e5d9b41b11ecd60ced326a85dfd1926d2dfb0584cc7554062861eb79c37508a147c2b8c5a3cbe6e28495f7ec5003db73d374e65c5f926478f143fef29b71f6a9e0da76f944fcd02a74931d19d264a5a3178d41c69d430d14dc76c06d0566be1c9a6dac08ed3cda1b243de756135b25b950848bdd65429f79cddc8470931ed8be04f722f119627d6b502cc2da667a25ae2e4a58b33bfc2dcc3a32b0e07f1945471993840b3ff8b37f1fa03c7f5b4e3568681709156b8fbe26f46ae8be09ecd2714bbc0e178b1cbb60b5207f523d6430ef27d84184457c9a58e100141d68b8ea98eb0b3a26cbd3713d0464594ac0ef0ce763fb5c9d89b01d5d70e4bc06527318e59461cf225b9f0ab5ed6f37dc8e141c4980a4ea8d15577d50cc1d8de54fe13248722137aa321a621b67fb689fe9acf2a1348e8fc4b9d2657ad6a946bdbae8c76eddef548c7fdf4a9179ec91920cd391941e56c81a202fd921189a6f2046d4e7080f036f6d8beb2ca2e8c96888d47e9f639c5826c156579746fcc6bca91785ef8661a5f1c9dc1b6e0967b85be2c9e3b04a684217e678570f3c01ad9c0b6c99d24e838be1ffa7648132157736064cd76393a8ddc4a816342650f8708eb3a5669134ea539ab784289f336c3314d84eda12883efccd2c30562572794eefc4b8f0d565c7f6a3a3581fc7c1a56a872532beab8717b4ef3493a383737edd27e23707f8ea9aec36ed903ecc93e87b1341c0c0ff025b0848f35ab3cb17af4f75f14e37b828bfc40c33adb8b2cde8dd8abf83bc55aa7af554b894e25db52504df979ad2603c5dc63254a15e8b33d31cde893b8ccfd464847d4594a47752fe383f64036e45a722bbf2a2631ae8e749f7fd3eae7cc6841ec3ef02638115aa44040d7858373d90be3d6291985dfadddd94ab0468dc41152650730a63b89cefe81a6a9f56ebd1def3c04dba1bb15f5b013407018768540a9aaf9fc6afb0a41533b8c12b856f3b1538ddd63612572507597c49c502e2fd7684c662a7103ef94a709733cb4bf26e367bcc2652ef886e613ccb287d223cd444de5e5314d225a84aecc907531116e6de8ba7b593ffdcdbb7c134aa6786d7460673b6f802a98449bb57bf1810291cf9abd334514404496b1b198d4c43be172288b43eeb4712409c553329c612247e6f836d616cf11547322d378c1cd4dff2950695c758e6fcef8184f949b52000c695826a4fe4e2407146e989e66a1fd86973d5219df60a52892c810650ca6a6d4d4ddd09fc87f2036c6c0f7274415b233bd5287285151d6244bb9dc63d2852e60da3e907b14b397871cd382d0a6cda677178aaf9c8ebef24f53bc98ffbf9ade18fc7070fc3b8b3acee18428b1be073626583a7f10c54f14087a234c213a3b754a29c50bd6f9bd570a11791ae62dfb899c261088f1e8fe5d6a040f210c2cfb2c055242453b36e8033a07350381d4154e15c448ac4d662918ccbf4eb4e7559c7bb4240b6d3261bd30c5cfcf661958d4cac358611b9d6b0e427f89820ddd4f89cb4608752f7971dabf01076bbcf2a862e5be66de1964b58db76899fb98a9692e0cdbe9a1eaaafa6db1ee9fda93596c1d25c46bdc1abc37c750603b0ab90dd5c3720c23c4a85150f1b7e602994b31855b1c6452608bf68ccf45272f6803da71299a43a7b1fd666a4dce6e7b84d26de31557c56488d7969c0d1b4ce4fdf71522c8d2b9af750afeb990306c8e5e71566a8fa74b6cf9c33a821bdecd23d7d4a10167ae729d723b00839df1ca7b76021b9ec9fbdfd8ef976bdacaa03d6ed571d263ca12d8366c7f7d451c372faa7a97d3400ec71e4237576fdda4b13e0cdc86af4806a041415aeebb09a1189c578e33a95cc50dec2babe45e07acb979c82b294b903649fb3a4597d7892eb35bc6571a9ebe5fc212397fef94db385b8a86aa4cf7574e2d5d8f31ee38ae37f13dbd0fef97974020b2366f5f6217ae4a25a42d449bda0a472a0fc3f895aec203f1f2798aae13761d7c7e446ec10d1cd14ee0f6b700e801f26e87f4d75cd9cc06e4e1532f5087ea14d9425bb319f99b3433043a2f11515a8c64e906b56a8b618367cb0bfb483a94c817191e0fcb043fc334260419a08991c4721adbbfcc77e33e0746777487d184dd6784460afe76d50e544f9d9419693466ef9478793ed2b47e58ebb8f3c9500f068e49aa995aa5237f9acd54ab772edb3ed76dd55024416b31bbbbd922ba2e7d20859d261cd203ecbc1eb6f82f3391ce2160fe2c63e6f813ab04318845990a0a3c4789f8ab6af11fc228d389d8e5fd453637aa77b8f3675bca99eb83056a24b19eb91dca93b995cb451a7b974ad8793019a26a367b609d8561bb009c5578024edda645ba34e6367b23e3c015727bb9dcf7aad8f5d9daeca667186cbfff571a58a41910e0bced1018232992994624a658363f35756296ca29e642b0551091a41c20f6e53bf1396da58aa36f932201ec775e17a5d291c275c210a3d49c18d648735204fe28e153a7b2c943e81d483f19f5119da97a2ae8698a68e112451f735fc6cf478be2fbc3b0e71788c36efa45ce48885f697db59f68f013bc9bf2eebdae325b3295df65685b22d3c0128df21ad918dcf1c3cc3b55c09753dd5b6592c4e04c21fd7a974462f53e94a904cca5fa79493c91fd418f7f03f7fb0f52ddebe9b5d538c7c201b8a3011bd2c69ee0f3b887f4e497efd379bf5d2ed8074b3fe19dc6be889963945c516565cda03366d1e17ba4487a985898d8bb83ba3044812e27d09e8ed930db7bd4880594744eef373b7eccb3332ea278529db28f1d8cd87b8cbacd941d958cf20d629c63e52d6ef514a51b5dfd603eb2c33a349a7b70d78df8bfaaa54f57dc7a59c15e946aa548b0452509551c82ef418e4f41e4356585fccdabd8a9759eebe0342e4611de681ae37f5615fd8fd512d676f1bee88c5328cc3d1ba957c1f188103096df033dde50111229929fb55715571b361ae8d506b86bf540e98e25e6a87f291e771dea93197008071d72a14973d77c5c3034e9dc283c0316c1289d2e889b24de9cc42f7e8c0316528bbd47d0d22a9b169267f66f912f446839c25f9fbe4a8e421c44bccd7f1dabeac0a713455f39141dda210bb50c4cb47d00d4bfc6077bd429de5e403eccefacdb655833ec06425550ebdd54d22a1066732641154264a32602663279ffee984ff1b3ed415c1970884109db3d5a4028937124ab9e825f167e41fd9c8797c26de62d6274eb0b5149fbdfee9be07fb10cc263148434bf2b931bc373f7d574b87fd131207f8644f1a57d4f21e7fe61fa2d9e47ca8f9bcd2be34741355faa10f6085f681f2b716b4f10a36e4831ba0b701ddd28ad44670f12085c65412385e6d7eac8f5d64be8638da8e0e5cc2aceab7710763150e7804429ae8fd1b971fa577fa41df1198917867da189771487a4376309702af81d75b162d475326592c59d5d5fd0e745bfc6ac9cf807c4d868dee159d70814b75a19377922e44bf2d4f739913337f887db662e6f4955f45ffaa40f57ba1fb4fff3e901d865ca2b1fb08164d02f286462b009af6194969de0be81e2231ce112e4974e9f133f8b62b7b63db567b6621434e39a3a7a1f2676605617f7f2d813ad0cd9a68502c8350604d3fcc41371beedb8539e5dc771bce308b163662ed52bd8cb11bbfa577962a1d79e61bcc83d98d57c6f8586a82da02eb64e41558c907c355ac5df81b13161bbaba6135d9a97695206589e2584141de34358308a794250788194bc9dfd84ae5af0fb37b2e87b5db7f696891ff1d055a9d4b1663ef33d3d111a8c59143d19e173b602eae2479b5aa53ff5e209664b0c8fe5aeafd1bea1d1349b5d175a5ae8201b6d72cf9268dd9c08ce54de364fa483906df8a5cf4123bd3412747f452a0b4c2f26fd26a8ebc1bb1e4cc2a4d851ac3cc01a5d57d5c199e6ffc8c1f74404ec63b82c3e1653d2a65f6bdb0b126e2a9189aa2a20483c0b32a6fc42df2534e9c326f1cb0be8ba8e2a787ec5ef585bc79f7176678ace26defd062f7622d8f90674132e3dd22f43f92aa132c12cac21030f7e45b65a5e96ec19ad05aa924dab9e3436f3d82f112a3550704f97ec463a0de8b4382d57b41c77caf6ca4ec3abb906b53d7bc07b53d51a8889179b7c77c9fd3589e6156c1061d2d17aa411907c22cde5c737a3ffbbc009613b9ffb854dbf01b0e43c337400a786539f48bd9435d8b0dfeab2e37ca8ba189dde5d7c196e4410ef51df64cd188863fe516ed715f049da4453d41f0ea13783f52f565d7a948b07de2ef6bee6dfdbe51c754e0827be5e83773d549b7ae36413efa923f22b04bc24bb104c87a0bc4548656ec85231ebff3b1699ac5f23aaeb896a7972b619ed5a05bd296b0b4ff60ee6b2bc9ee946bb59d3c36399f479d88f2401142e20145d9e44592c6172af86e086987c8affcea572bcd56987e2702cb702c50353f1feb57b0b143756cabc78472339b68bf81f93aa8db900d6d333846b8efb7f02d23b343c9726b09833b48329b9c488f063584d63f2da5da5a1b8e4adbbe97fd01e5f8ccf3c29c06c11731af90d0833e358b02941051a5e07963bccc3e589e2a9db9f944c77eb474dba04bb955a69300adb680382b09587c60ad87e3a9f87e7a146863e633ac8f70bb0986487b36ddad1b4e36502c5fa10e614d55418206d7d9393bcae16e79f4105a36fbd52f30fb281c8c8d82c97c4daa4d42d0b5f6e8175ab7d830c31fae09c7cbf215af3bc0b532c6eff5a658243da94894fd74ff7d9e1b46623f53b1ccc06232de8c78b6a37053311a6cfa9b419b3b8ac0a0e8fd4c45370e84418f244d670845f1341eff6df5b26e5c3b0ef7136c572eaed1aef70ff6574b6d63d5c1a46e49fb3ee7cd598c63bbca28f1ebfaf8be23260bd66c392278f11ef561ddd2eb4297d0fb5e2d8bbed87e33dc4283ed72bda84464c36ef42f90986c63f0d156ff87ab6f63c28908eb0447cf2ef83aac395e63f88c7ae40269f6aef011f2e73c9349dae18d5561de5f51a847d0f4993f9452a271eac38992783cea37394757c52c35d65983dafadecde2610913437affccd32cafb0df5043226a96d5e4a7daced100cefa65b2adff240ad654c42602748c5a0f3a5e49d2f5e9386607beaf9ff6d34e3ed14d5521f877b37a72a82203ce344626aea20ab48520ee9a3b0fb1ef37912d172bca011ac78b81dc4c08debc2f40f90c0604996b84916fbac571318630c5e63766d96d64686f45f29ab67f46784756b4db23af83b095d7c70d13e65dc031ccbca5443b18fa854c1e1c456ca6420e3b8a4cd1ebf4908a1700ec25add512cbaf302123348d5ebfd8161811d9b357b13dc1b988a795f7804e095f391540546c59d979485a900205eb7f8e26150a4536a20ee61fd0a991d9172e9d7a58ccce72909c27c53e81b110058f9996bb27e3e8a2cf29b7c31a2df61dc96b9bc8ada343179c498b7896b608d2565a81f274e56661f9937955d8339b941fc19a47697dae7cb6e9eae82944117537db9ce41a0493a464c6d5922def7c21f4de5f7283d496e5fc97e062fad428d692c9437bfe5b6f82a5e91db3e9727a23c19075250d59615cd3c82f65f3819d0f5c66b484fbcada79d1eeaf02738085f8300c91fe804ee7dba25843ee9216c356cb29ab0ca7609df2888624db506696890ff105facdb80b2e85017373b286c554f673d510cd23d1f21bcd8813a48875c3bcaef359d6079582eba74873a42e0c3eae85766705fadadca021ab25fdc707d7148069b5c61957dd73355b4d65e8c81f227460cc3a2a2fb89a1a1f6012b09457ff1b93f35138cea9959b824afb7b55775d06eae6ff52162588df4b7e18d51479a0f32e3ef04b8cc94dfc87827464ec8bafca2e781d3fb2300286d836814c06299057f8bf434aa245429ca0809448c15db771ce6131ab70da3b9003f3d09895ecc9283990fcdcb1752d1bc93abfeae2cc09db69a853742054150144ad62614cc482be1c73574213a490ed2415dc922863104ebffc19eeb495c268177223ee9175eee276fe3ea3691b75b50569a4fcec1894d5fd16e48f310dceef49ee68a0a5ba2ab5813ceed1f408b06269c1d3e1c38311ff713635af14368751a70e44d557b42c36e4fce8fb7d9ff25eddfd97eb3655bc2172e1e3730ad66f66e022e883581107ecd038a9d6152c49cc4c4d0eef91dcfed2c536e58b0326a6d587f942432ec72257e58e7b82bab1f94478bf8f813b532b243240ba8cc1ebeb47449acbfb4f6f3b1e6a8d851f8376c6c018e3baca80028610e726eeef45e3ecb222238b126575d1a9a9945fec76da6f240c6851581396d52a504cc6c7b7b1163a16b9f6b9ba6156fef3ae26591190423680f88dfcc28bc2314394c5e0cafa3d8dc365def3191ad778ad7b74f8f13f7849c8318ef8dbe98c43a041d007cd93047b8ea721ab7108be821d2129f0feae53c459e8a6ef9b291292d58b432979236509d8f54b8978066b692bd1de0f3bb484172daf1402f32ed575ac11f0afb21623130c48c08d0ba9ca61a2af7720b39ddb9c38216854608393a3f9752ae486701ae44d0a4f37ea7e3c782811e470aabf0cc67f427c311aa73f9087a755f02d949d03ce85e7eda622f2e55b23248ec8eb6a7ae9f3922a100b240eed9cf8c50e47fb3bcbcace4133e9d6c089b8a4b9a3bbf226b11a36cadf277f2232a3fbba5e9620b6e7683641045026e39f88001036f3c899bfc4701aed8a34e4cf92f083be7ff93840229cdab7c883f3fda4fb404828a1d9c4a2c577af84e2648d9e34959428486450400a4a49436859225ce82c4f6037b89618397a6b9c469045d50106d691a8596bfc54898063269effcab075f92d7c5bf7421056621bd6509a451553c50e1a8b506b699d5cdac37347442cad311e4a1c187fd19b34eb7f226de2329233ff8a94f99357a6e3dcc00d96ab45b42cde30daf3f84fe03c4fda3b42438a7b7bea35a5ba08d1e640af34af2960001de4377bd491d52e40758715b17d2611a002b4907e3a64ebf0c7af90f765eae69c26d0f5858988149b44d3169b70d2fd48a785a312d8a19bbbc11373294ebc48e4b5ce6ef604a9745414e425e3c48147f3c408250ed65c4a3f0d14b9a80e343779aff01e8585524ab4e10709c2fb6f9dcada2b9a9594ab76c6da4404871cc597a2979144bbabb12d707ed01ab54e98b488e5c09a2c557801485aa8aefbb41e47f8b34ae811e1f746ef12cb0269d243dfefd1932f3a7f695f60af2dfd324cab4faaefb8407da12506ab13eae19d13c225a65c839a5b99f2db3dadf7537c8621defde578fdb3519f7bb2d87442fcac33bf3e3147dd9a39692a5729c6eee9df3a58953196631468647e3e475d21f2f8046c3cea154dc02c1e1798c846cc666d5556f875cad9d14c8f6802dd2dccbcb55248539a8f0d150f1e0eac077dc8085a39a5788bb51d871d156ab4e7b07267d3374bd3013087043b0329e96bcc6da0b63ea68872e010d8f13dab473d1f351da140d7ec7c9df77d1cc9b34348ace7e1abd50ffce64eaeb7858552201d0b1664a9e3dbd9acc33c6df229e75cac6e6575c30ba1be4562f20fb2aa5e9a4ddcf2924d6eb719daef80186c942931aed8e32cc762a81949f9217ffeef8dc5835cb008315d34b6ee10975d505e1b6fd8ebceef4b6a0a2a05c24e5640838c04e0c8e25a4bddfd9324fa98f94d98cd418f1d85f68fd099bf9356fa25795937abbdde45759f4815fade6d7971cbcaa4486be31d264c5faf1f53508fec30bf013ddc5a55c5e3834f2022987647e15c684ac413eee5d68f0a37b9b3671920606f89d88a0872bedcc077aa1dc1a4405e79c268c02b863d7760d4ec16395eca3374ca51d4e2255c0f30b3f7863b4f94421d087d2a249db4aa16644d3943662b9abf613bc36af120122162c84d8b91b0aede7854a22eca7cb3f372be2d34d88107c9cd09e6dd45c8a322706d944f005a7ae50dd8b194e16b06cb25af2c5909d4050a76879a753cae900c781d0a62928b9888d4ff4897442cdcf30620dfe81c9eeb6c6875a7a02280a8b4b0ddfa4b45120a929a882e73cc62a646711d8b1ffb6808dec5b7a3d79d990e0d566dc91241dc323be8f748e7c6b40a0020b8a62f3848a417581e035e8d6ea5d675a02eae5e320bfd58e6425e65cc5aaec8fbaf6ce03749c05ac46061a408db060c29e1bab22089a943f180136dac14f4b97a47543bfe31838421c34c1672a4af136724ebebf7f85e9f4764200844fb9ac0481ad20ae09e73a477de8ba2aec2f6d49d2578dab3c835c29c5bdf53356486eb114563f9d77c324e2fd464ebb3ebe3032a19af72dc0b7c0a697536b812b5140430e24bfacbda05849ac2ca90c64c550eb5c7874217d37a1e4c56005070b57ba9ca2e02a35daeafd9d8dd3531cc9ea0b7ada270b79f0cbfc94d4b80de199e0c2a749ea698a6d81dd8e2d8cad572cc1ce6f4279076d76c6208ac8b9131ebf0d1f531b4a084e0b85b6026d317b9fc6ea961cd7fd81d9cf47bddb6c712a4234ace453adf7328b100645a206862114d44f92be1f41e39e43a0ee4400ca18939d88e21d239d82ff1a8f9b4e26778371785728dabea606285fb2fd435bd1b407af2b1bbdfca204573d98c663e108e92246e2204e78f8400b43b10a994c30ce6dc95cf293770e397044106d6865443b7800b95877c92b031b9518731e8905f34ab07f65a34c9bf9c99c8e76551e35f66d60a23debf1d2f02e10efe1b928a6df14cdc75e624ec270c13d436eb2f86692b0bca316306263d7af606edaa6a2a82d6447fb6c881934170107d4e4b9847899a622cdb0748c692b29446690fd7c5325ee67ba05945a2e1bb2d650873dd8b3e5b7982d87c635d732a1b92aebf1b5e742144c15f5cad9b20436ac423227e86f4388be0aa8fdb26c96d8ca73f9410ed0d4bf44d26dc46e504ea3ade926f7efa8c3f661066c5e0e5e279da0f0d9b749be2708606d89fc9bdc209cf2c5bac74174900ae677fdbc8e50613b5911b8b9b1e0485ce2ab8d07c5b0038857cbe1cbfd9c0b99f1918344291c4e4372a61fccf124a33e2f69d2d2fbca623a8b6264ec4f726df1e7c2c9af9ac75a175ae0bf8e93e4d64bf0f94772578bfd4fa670c30de3c0a6865569c42b0fbbe6884f8d629d201586df495f592df1aca2484c60ac561f9291d9964e9ae547a3b361401ddb397bf0759d5b1f9fe8f1a142e84e8afb7ae6b4b41641dcbb3e399cd5d4da1e4d5e47032373718ce3b513c328259ab71aa985ae21def1866d7904ee4e3f3133ab63c370efde29d1a6ac53a279533961d53556a30b8c41d012318ece1fcbf888cfb1f44e0254d0fc304d89f70a659fbf2b375cf8ac8f9b66a082253f1b248b554f73add9be2e0a4e52bb1935337267e3d6383ac5ff3e27e353e4f83240d25626ad5413448caef301261a32b15c855a60f73e598e27f25a3cf88cdc7bdb2d1f44779160475af1365a28561d9e4c48f2dc00d9df189c6ea3f6671670eb227929a9ad535718e157d054ab6c09283b7b739f9ff5f69426b8e439d2ee949a0ce4d5984fb04d17404ad34129e7f3a0531a36cb360ffdaf85ee1302d27157dd7448632deccc1cb95d30b9fd2e55081b99e53f677200eaed06813e7b8caf0a973cbcb82ce17cfba729657c86b4fc2e625768d251c40a7c8810ac8f2139aec5de832579ef0ce5803a9e814b6f8c5c9fa77f21c6cf4143338d2af52d346ffc9b9ecd010a5207f7ffa8cfb0e66685c7f028e011c2872319aff89ee2a11c5a9adc5a9cbc791e7bf990003173462f07a560c6feb3c0abfaa210fd511a5fd5fe8b885de3d29db79438ce40cc6abe095d17b8c4aa2b5d631b994289311","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
