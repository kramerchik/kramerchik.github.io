<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a96632a04d77144d77cfebc1bf1b66eec128a3e5b019d75caf64a2cb7c052f433a4fbcf68dfad87391f73de6de5362e0903106a89a29c882ab5b7dd3e0624ab3d640d4b675dc548a293ebac3e4b7345b73f18eb4cf23c0b4454afa1fb022cc9ebc400e19ad4cb6f24fc81a747619164c7c5fe9b4125938d13f8b4858aea6622ccdc745b940bbdf155eea46d1f81ceacfe002a7214e0471514c1202daac6b020b7c7151fc37c6cddf6a1f1dd6110efeec86d8c7e03f909ded1a01eb9bf5212843b47140ee8b802ee6a665ea96da28b971a950cebec4abc765f3567ea854d3a43f5f65986824485d55abcef738d0def448343651498b3fdf2492f08d1b94e5e3c9e59b927cb7ddcae2c692bfb19d3d67e02235b6f90296c5a82944ac9548006efc8cd9752404b8ab32847c8e24e858f8d30e0148d6e5e39fb2b4f7ae577e54b9cc6773472b6825ef1c11d42d43e1171fb7aac2a4245bb30ade415e38d0daff31c434f62703b1492b61d61cf5a64ccd047a4081b9e52f6b317990cd3b6e5b115f8d0e442943f4f2da456ff8cfd3ef988832f0b404e718758a86ecae5f5139e9cba724020c75e909eccaaa7107f2093c3f2feaa522b7286b734c23f2154408699b3aaab81708021ca023c9727a3147bffee8b9e5764b291eb31896f9a26f7e57e5977826e4e881edc4750306f333b7149f1a30d503a307a78bea72dac93a0d430802d66bfc57077a6b98f2dae28d7ad6bf45de7f8d3b3a05ae394bd1b126b1d59aaa77fe316fcbbc8e76b7fa8df41e79e549ba949f1341e0df3035390c3c2a1e318bcf5f956e09ac035fbbffde06b085fbdbc83af8d0a05850cc60a531f24554dc7d1382f89c279250673826604b454cb30866913a38653e5743645ee311ff42a7d9d928723047884225c99bf54a297fb46fa42789533b68c4897733c71a2faee93e61083755220366d2d4ec743c150540fb87775a5f2eea1085a1b245d33e31fa5987f60746e59cceded1762de2de99fbad6d1691ae5160d3c2236d41485da9ff19d0a6924a6e91a108e3ce263ed01aa6dddca7a95b6c7c8d64b06204b2b9d4c572f1bf6fbab3f79a5524b32b6d86a183d1259a66a87cb111eb4a6c9f9b1e0610f86dd534dd784401ee6cfee51fe0651f3f3830d48e84f3fb8f9445767de644f5a65e00b1b791df2104c44e9a4490d79ef087b76fe36d4e14e4f35120f8ac727aef1d65ba94354c159f785166bee181b7c99f678d1f99ca40e7b3f99ca65782568ac21403fd5a05a24f3c8dfaedeb10d0189ba1e82cb3543f59cfc5ae7a393db9397c68b4247c89057766630bada61772c1455bf4a434929e17a1485188a53bcdfb594625723e38959dc39c8e498760dcba9dbfc9ffee333023b4ba6d5bd91943cf2d2abb0e25935d19f3c7546bd8545d4626685ddc078de94e83cec1b4341f3d4079c7e29485e76811090df2f95af7ce343ad7fe0185bc3a97329bc549412b816eed5d852d0a47547924d732f8c99f3816605bfda44b97bfe36761bdb1fa1aaed920c0576ccd4f3ad1e83258dac6c9392fe3761774a29f1679433284431b6cd5014de902a697bb93861b27cfdd2301fd46420ac6ff82faf2cd7be4f54652110698231076f6244f7f3b9e87c82b9471392de6cd956c4a21f6d6834a3ae4f297e6ec5932530a672a969b86ac3fdd79988d7dd23335a5cac21b862ab9086230d6743ba8fb5c2bf74301c72a1dc355e885dac46133a3adc99c7b28345b24b032c00a87ebdc290702d0890c737cc9413cea68c371496d504d710fec35f677f8e9112a4492817da82c05f8ade1684858eb30c6e34d21dcf581e5e98b283f2f862c9324c36c25bc0c65c130124a04361e1fe74207472ddddde72223e1bf63eccc27b0ad01e55389277c67032cfcbeb5e1cc0306d16796a27095edb2b45a35f9762c30f989928376664f34fc225b82b18df7922634a51c6dd0f70a6248c8c5f4ba7877cdd32cf60fb104cb3d81e0105287c59edbe6ffbe5c5b1f0185b58961e96e196bef67ea4f90e6438b0724d2b1e0ef7dd71f25fdea879a3d6b8d2f159ce35a49792f21cb316ff63776c23bdc58997f0df6230b657966c1e5c9b67c29aba20ceff23ac7646886282156ba8ed481207117f404f895ef65de80574ffdf4cf562eb3cf2b21b9bdff458853b3da6ee307f1f85aebfae7424c0caffacfcaf179c8e14ff7f94ee4fe47dba40fa3ec72ebc7e1635dd05528cc2c222e5f18c5b10c7a090c2c713e421ef50bcdc8e509829538de12848c0f43c98c076feee211792690c0e2ba789449c9a4c9608b63d0971c5e73e3750c98b69044e624a5b7682f6c6e5c840a0afe603939f5bacc0d29f0f3faa77ed30579534c9ef368271833a750c1dfd6d126e89d44f5b4d582a28d20e52758deabfd5bfa23aaa8de1ea0d56b3d227d64cf97f2d7896fecf412e01057122b91188a78a7f71c919cffecc1a39eedf816f99a7c600f4b4ad3b8d3075cd9dcb0994e4608b07a90033b23ad4a659eadf511181f2cf8d6906ac6e96bb55b3c1afe13d9148e605d3245477dadd3edd42489a0df0e818fb6dfd10b498459fd5fe5fb8a909fc01b19791e485a285b447bc9beb011aefb1ef80eb65dffc741fad07eecfab43c9f8b4bb855649371aa0aa915b2ff388c89d02bce90c553227e508c52686506188d3b5bb4e2b1437ca05d916b3040f10f92169ddb3b2bbc383a320bb540e3cffcf8491672eac2aa77c75f8a79abb60864f50bf8ba4794512d3e18897d525fcaf69b9d9a12fdea1528dd08def3db9f2262e9f924c45c50a0ae916ce2b6567d3d67f05b8a874d2cce40b164629b200898e9ed9b3ec67cad8d80594c4ad3d9ed412165be48199a403d301eaf7b7cb3efc86a4c0edd8cdca85222cffc328670b89b70c798a344fd447888675feefdc326a87c29a4269c0e7c9c69e6ddae199882713c702e71bebc6ff1a1a734f52e26636fbdecc591b84ef46395820852f9ac6c62fdff6adfb1e75117b924caae54de43f9625942f35b4b73e1128f2c21754e582a0a6372fc141c6c0a30ea1fe08aae7904c3d12410c208b077e61bb86d1a52036a288508f31ed1256bca853448f76e737c0fad01516225a71d39c7bdd4cb7f4822f4cfb14f2dd008baae1ef496a7443707bc2c1cfd1958ee2ea3767910e1d43ab7ea2378412c4cbebaafad4b2d793d40f9f9f4884e0223b4198d2584f6884792451beb30d3fa9484497e6757bbc1c07bf8fde9e3d8af6dac19a4002d808b30815a9c6f44d28b8c4c434749de4d87020c92ad15dbd9ba2de0615c4edd508115fd9b23b9650744a6e207d8e253e7875df2f9e238abd0798aa43405b3c900747fee00ead03f19c610883cb6a73b2b29fbcf1cda8ac37cbf549bd7c7ef5dbc8e361dc49546bb261bdfd457ae03af0fab73019438ddc217cca7cf30ccd8526fd6039d350c65714a0ddd392fb931287d92ebaed4457ea0669171f8e415687ad468739481e341c758e8ccdc4d95b4c20505a4cbde1978e57de5cb6a9eaf6ec95464915dff61856821369d6807f3027942cc03425cbcf517e5275e3e93019b3a5fd41421a677a78b59fa4d0e2a7ddce3dce60c89988d88e53485f6fc5d38edcc5bcfc718980c474a9924bab3dfe54469b98a6044cdf193900e88f8a8ac90b75d0aa41544fcf8e539de5877b3010c677a258d145e76515a471751c9b0ec3b932d2acce39bd4e6af5e8fa5bbe772b51d409f450b4dd0a7ace41ffdf0daba9069ad34f822157c890c2f88d498847e376291848d3f73df299f75e1cdf56ce2512562f2b43027ec6b26a7443cc4cae08d136af57caaca0562bb79493792c64eb2297777433dbdc0377cc42be2e19e6400d42f73e50e8850c4b69c0e9346312ccce50ff215287ff2f656103a324a536762504ce4210c85ccda574961bf884566932c1b9fbf379cb5dfc5bba31af5c51ef2994785b9f1cfbf0dd278edea1332bdfaf0662cba52701aff7641fb45b23c4d12f32d3ecead5926edb1d215f622b6ef3021fbdb6589518a085a48ba1624825c0b83e9202da887d7b78b84c97f5983bcd337daaddd666dac7b97ff806bb11cd9d71bea904a123c121da1b97e2a69bc6bfcf965471cd4e5c3ce702a8bb409720fc288e93d2f87dcd62429607641ac15f74cbedcd1bf097d9556692bd4cee2d883939a3f7be6c8baab11bf117664e4e85219276a24acabc9b7f891bf26448cc390aadcb17503342f1eadb55215165e7f3801c919fc07346045a9d27fe8deaeef06d50f1fc7d2b64a0fb426902bcd21d1f143014ca4fc4deef3021993deb7a2b39a366ca6b839078203e93c25e7de7ced3b84e9da4054f6c6ab55e8b1c30bea5b28069d10ff32ef4b964b72206bb133bcd2134ec9680bbdbe2af613f309bafa7b93b38cb99d28cdf69092a981aeaf9afafb1aa49aca19a54112638fbc01f041d5cf137e9d8705f453332860a0333dac1e63fc715fae8a9aa1e580da7185386e13129c20d55e2a45720810743af63dca368c2e67a60a497e833375708c473c4b08e2aba2fbce1dcfaf6dd50808d49437492d9c02ae4e4edb67e0a09f5e8b97d646dc2281d9fff693774260d249094c49c933cf009dc510f0a29f7add1aa1e7d82a91480bfd73fd6211fc70b65907428c21b51bc3460de0cf43b6dcc18cce1e217c37e3ac57bbd075daf85669cc24cf0e57070ebcfdcfee618b063ec172f2075117576f81729902add4b5311678359cc3b876b3d591224bcf24762096c932b797b16d1e8908878debe0309739f52a495da59b353f49f65d8895e5deb572ef4823aa19eab766535a2af7e05b545f47308556ee01f7a37bd92284e9c92206f4e6c7dd99e4755c4794a18acac576d4c2a39c97cbd505ec8dd5edb67b6de0b58f92d3fc9e3d57316225763e0274cf215b37f0f5db31c343acbc31fac2f154dc9ca8bbafa1539b3fe62d782181e0718f7d57b72aefb2c5d669ae4ce5e0707f03e23c33abe04cef7a322e062bcc7d186f820bf4db54362889f1e94579672048f521e48b1ed80679768a3ff2bbeb0578a35e50fdd1e682b04a36d8ffd81efab53ad007a872c3a1078bda6f1b4014bfec7a6b3e5cedbd404f1560ac6a262ad58852bacadcb47f2d66a2c1f96a3dd51a8d991bbf37b7a172979a94172e2457ac8e307dac4c7eb9ee495d6969ce829ac61b104a28224d4335fcd1a5a49be87be5ed9884e7cf045ef05c9d000c4d2404e9cf8bc82c33086f9a9a3a9822efddbee0d5731a366d3056a1219b147f9511f4dea55c4bd6e730079d3c03bbb0688857a1db143039ea5eb993b6788d28e2cd2b10ba3fae608cca482e72a7c452606b08c287db2e191a2dcfd09ec00b14e3960f37b3e337bd1aac2deae226e0e45fd9f3836b6e8aa5e95b4f6ac9cdad05a29a3d4b96027f646ed68e28188adb209e55be0bb4def52813f33e3f9617696dfb9ef63c06a784a35b0a8a7ca75f0acdda2adebdd84e8c86231b07d037c6cca211895197f5c7be5231f06e30fff1f5f3b818f85ef565f8fa75e238ee2a70fd8e37f6eecc6ea6c5d324c5b53043c486917a0207115aed7a91c565cade6e1673bb058801b2ed69f22479d2b43311ac83c3a7cb438ad01c7ea36ec8d08acd8b6e3ec65fc44b46c4e5676e9214622356665af7bf00efcbcb0086960b9c23f34f34cdb018dc6fede14f473e4e62c1213d198590294e30c0debb6eed558e9e572859bbd87b7f9c80d9c1d44c75633ce59f61f2ddd8842a57e8961d6d573acad439c4b3c66fb110c5b5cf3dc8410cee1b59f66cc89fcc04a505cb80d27c32cd224a6cc9d49b089d51b82bcd6f958246085556194981010fcc59a9b379470bc05f97bdd7cee87fc808649cf95c793534f5680bfbee18b2a33d47f4ce450d6a5c1be0107ca1b37aa24fb531f334e9f13d98758d117a0c73126ac359d070b2f6385ccee98b7829b0f87208e06e385586fc62d9113ac61caf11b929499f96dd4e97d5144e14748f607b0dc1361520e938c1263346a8a331fbafa935a38641db18e23f1241ce16225468cf01a4efba2a7454258903c2586557e17d7bc56cdeb8bc0b1a8927d2fd33f95abfe5859f2f7c8bb688a07aea3b799e43982780ded5a5660e42c8411391eef06db778e488429ab8f1b36fcf82757b043d7e10d86ee9d5deb6109686f4a4a7f45d06577ec93ca3f817338658951b15433b93d82514786bd5f2e7a79371797e85aa707e873335e882ffc24f0b3cadf762f658de61ff07694d1b202e8530eae5c0a9d3c3a0d11f9c405620d1c0433418ad65b9f44b74787b0b95b59253d3b3e3d4b078b2afbf6a07f0e1a3250e2a7015e4670da4bc69069d91073413db68d6f3308cc65b7a08f22501c0284ebc7ca3fbb822fa5ef2d4db6bf7990a5088c09b72e75bf4b966ea179aef69b47d9296896924379d84051bcaf670a33fb9eee3997702227e2063716d07ed77dc9c40e8a4b1f164d14ca540cd8888a971c60c06bd6d6194e714d16496811fdb33abfa63c87be2b1f4c646e9373f886118be79a430aba2452828561f3dbb30deb342e156dff032e38b793cdfca8350012586b66e85775bf762afe841ebfce88ac457be9a680f0f2c9ba4925c15053d0e7a47df0fca651420d41faf10b4c5a4f651e927e104fa08378c65b6f25357f6a370c21c183ac48109183786c9724e30ac773e46ed48c2751d01333f29d2faf391a99cd4393bd2064af912b8b6b5f12a1a86a63fa24c87de0287a4cc5a2797d55d732489ac89de3413bc7fb795c28d752434abec99f30b3743f17ea0108edd8282158d3e7d64532450b34757dae83bdd49bca68c3bb85ba4c7ab9b2bd62fd07ab56e99d1e7db11e95babf72b201a115540ff60dd1c72edc63d58e18042514b122131b032fcb2e6751aa651170e121f5d727cb322772250d04d0d28dc5f65155e7b77c1b17a53fcf2d7b073ef7ab36183a4063761b8a68f66e982e693ead8c9f5cf932e8135e62b521b213212a3e21d1653c27b4d2785da2eee173d7b04a9a0e8e9034be22b2108339624f7b45d4b1988d71999993bb9ab65fd50bc86437514708ca515195cbc5f26c8febb9d68a52811a22407b61e537fdce04513010a0e25ba845c381682096fa9b20dcd61f767e47a4d565a229537b14862ad361cee68078facd0d4b71e64df155461c15da46dcadde1667db911e34c7fd54e498122eb88bb5d1fdb8bd034a37df31f82d896f3d887d263648bc9887074a266380d1f6c2eb0ab83ada66dc7511ab404faddf865e8fa91d0770272f490515773d9ab62ac1497d434eee9bf09247011600b30d0bfaeb788fc24171783a25b558d69ec56da58be0579715b90d2905754dd356db3732531fb967e4ecc44ec7dd1ffa5f0aeb7f4ddb44c467d7430ad3847dc7c127b8ed814e719e2695f55521b8c5aa8a63650741c25e000c3c31960fe46c4ea569cdfb1d2e0b0cfe1c93045446c8d963b5a7d20c205bb6d69432ecdb858a129b503375b60080b794070aaea710241e928c01d378cd2a9f11309650b3df89f3ff058e30f744a7948684999f8e30a5952928bb2626e244fb33f2c58d5dbdd227048aa094e08ee0a29ca7b63210d00fc8ef6abbc82cc3d3d652debf2264cc3c5f0d68bf864ef26a37445fbc994ed5c5f84058cfc1095d62168ed3833fc454123d14b86646a9b4fc6353f5aa3969da41ec18ba03f7fd9f6fc0a7dadb92e1a76d5cd76c482b0d823a16213683ea2d197c990937a36edc98c15542996560aefed27051b19b0db2c485687669539ab054f9eaf96bfdbf43faf3c10aadccc8f025aec8ce4f03885539e138745bb3a0ca9d27c0f0921f567b778f3ea06fe5edf9d07862c0090c941db7e5c6a475e4a229c8b1a8d19ffc45f46b18c458c0c2ecf5023d3fb33f64547491ca88e9501ebc55d6e9ee16bb0290b0836fff7aabbe8ff5550b97b7aaa076b68275569ba6d13002bf051e56a78989a3cb4b04a003940342a92d7f54403c21c7fec52964bf5385c78b7f4efe77e04b9b20d7ba93fbe9073c646dafa56c7bddab7c7be40ebb7423ad444842571968a062a74f71d058ab295870ee52e134886ad84cb5aa8e52f11a0562efb5a50a7a3c213dd855be5408661df98d3abe98b5ea531d50bbcb2e8179ca95c9761ad0417a7df2652ea63c83b93eefa57a4fff7d522fb71570dc24389ef1e33d298845836a5965e02a47f14f2a1bf3cef23227049bd58a54a93a1fe6e35e1d75a966295526ea0156e723cde27e7636a1f7ebed7b20a859fb5d6685140840ce1c8256cfd76cea3b2abdf0e60a5941da7bf5b4b38730a8752db372bb3585d9aa563a0769de2c5939e72057cadd7346ea4f28e279071f02e9c9a787d2b3b1b7ae12dcccf189243aaa9ab0b3c88e97d66b4959fdcf5d40116f8ed414412ca403a6872ce63f6fef5a5b79610f76ff2a2a103a905af1f285a297f28683962eadd775ac3b589c26819ff410054312e5957252c09ef5b118421191bc193bfb994fbcd14d28357923349927b8b45ec2bbaf0744ae9c90076bd1307048f237069ee19f6fb2773b0eef3c1d3cc7465ddfaf233f75f6c116a715232c109e37191c78ac1ecae31ea3fd3a2590025283c0c3d9bbedbe5beefa436e86b2935b14526a83018587f604ec747421b1b1177d64f97a896e8fb1a3c74fd28178a52689605b2e781195fabd4595d225e6366f2d0c3067c557391fed520b9fa53829e0cb727211966fb48b7791a09b1e86561bee2f41d4971d2e2a616bc4f3eac06d904ac7360c4c3b87be542ddef411b3dc9aa721961aa5ca657d8596a5457f3bb90f4394e72a371426c08f20a32ac73963c5c98ff8e0e68317e8d81a0a867c03ef854abe1a9181094b3041bf00e74184f1e1e8cac6b3c0babf0906e7dafe4d717b718fc42a7e56317dc1d0dba8b70c910322e2d49f08ba6528be628d421ab4a2f6c53a7a8dca8dce388baf6e677594187c43111050ed9d344f84000588c8cf2632442767129af6d71b233d90d5fb851eebc5b6d99dab5bfbcdc2cac3e073dd62a24503285b8d911fa15077cec0a606bed66fe83cade57ec0f0a8eff2b93f91fa6ec6c2e35e292e21fda1f69a25f7d41e2d343486aa8d6c88c9e181e113b9e4b7e0e8b08fa73505ab67d681f3b8c7345b293438fa3fb98e92f279c23e9173e38ee5c0e99febe731bff41f788a5cb2c01438ed6d5b936776bdd811653e5da55f5a8e79ccbaf3cf29599926da38fcc18ceaaa59b1ee2bfab2159229a3b2a633bae8481d98003f0a15d7e69c14d977116a6bad4fd4776f92257fcc22303510a914fc53ed80ca3be0ffa4c62477948c407b0e29e24a416e4df9ea649642ee8d48f4ec4c48234d11251e8833d2881e43fb4e68e7ad69075af1436ef97e0be372eba8fa2a52247ca1bdb94f5f9d7ad419a59e3aeaf99d30717491192c895f69a8583911b52e32f51a41b0534d9db7f0ed38815d3d121855f71ac707c547671172f77b5f769e5a7e136f85559e089ad4d9392fbcfcaa63377811317c162843d096d3bb97c2ec535105b3d3eaae150f8b0330ce4d8c160c661f5bbfc4e7d670543c8203af73f3e9495fd521cefaa9c074ffa2d50a5e9a53fcd454e18eda3ff293abe393700ecd96c54f563358480382ae4ede2bc901b46b46ab4abc3f816d96d29d7e3fd175caa2655e9b810ee857f14302dcb658bc360326f47f38342fa615efb6e115ba44b0dc5b1cefc0f86481911b5ad3178e771e4985e82efd12fa7ccb158379c678c656c9592e25835abe8b9d255cdc7c5b35be552f9cce7e5f8d7a445209016065d52c471989ad55f5775760636ddc479bed7cb0fb6653a903ea407b36f6d137928ec927ac765e68e3509a6884a7a4b0956a399b8e760943aad85aa5bc3a891fd754efd82b62404c5ac6a0a8915429f9dcb0f4d4c35df4ca93713cc8e560465463070b939360bc7cd98896595041c9dd5c19851efe8107ddc7dfa08a830102470f25b09bfa54f298790b574c9b622cb75b4cbe0cdc46519ea3f269984a2782a85e2d4e1d2c063eb0af2b5b6b0707da69742f6eb0827d0eaa7bf98705862879b296744427e0f1c5e75bdcfb7fc9d51bffec8515b7c304ad781e2a5d2d8ae449e7cd95344d8608e73d393e4d4e2dad04731e213fb7deaf5bc241717108c33b05426f2d686e32ebef7c0ebc2f6020dce257753e8f4a5d05010c639cabc600933eef52cc885418479bbbd83bd8ce4487f11fa1f86327f9746d4cb6045bcd18603a60af44641774cb9adf70dc940a634040f0046ac97eddf1168c894c54b73bb50ff63eca3fe0eb0f0b52c7545eea150d70023602c4b38a13dd5db90bfff62b9549b2c0dbf5a147bc5b4dcc6a63a573d6c418a80e521bb0edbec80c428f68268ee989cc689f3592b9d9d90a355d46dcd8aa6510b985823e2385552f0c8cbdf8520ed581adae0350a5f3d8ae054d3d570a176852b924a1a3b5432eee7f78c091e8eb401934365f3d12580e74526a6a0f4620e7d20c91b067c77ef98baf2861574e7a8b7a86decda4c6aa209e321b5a9df0d702036eadf620554d29d8c2bdddc255e4a4ebad108d3aa7a42210560b28719897598d299ed61738092ca9c065d6776c61addbfbb23bb12cd02a52e8e180a542f483c4a121fef0b709e769be6c8f957f5d606cf9dc86115b7d877ee4b0bce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
