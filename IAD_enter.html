<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce6755eda23fbf8e319a3ebc9708c8d226370f8ad2fe72abb2fa055bee22de1636794a2cd6f754b5e549e87e4320a942c57d0f5599b8c410a392abb795fb729493a5f6d13cfec4c674cf7f89e424bfa007c9415591cb04ca2b5c159b397044412669e605cd0ef3d236817636cbcac57db83b60d3ee144e52798203f4b6ac31d74035c13be3aaf4fd806f8ed10b8d4481a1a9f847687f382d9229632715cf2d4f32253210da19f1caf1c99e148567e309098402155e3d7af159f67e907dea16b00f663fe9bb3727e0e6c0a8814baa145337a3eefe9eee6c57ccd1a24641134665452715b1be9df06f1848c04463d49b1b7cae339d63178ce1230af75d61565a6c30f63082217d2a5bdd02264c0ec91929fe9de10f2edf32c6fdb17143c950f7f5cadafcde037201522b650f8ecd8790fe86a159e9ef6441f22b811b50fc8c08630e7d1a6200bbf7f12aa4c785fb151caf280808cf06caef0f8a3f99de6e9e490006e81d6e58b264b905c48d7a3ce05986b44725b2281206bfc2897e42cb86b6b80c671d1abe696a4a60c587e7d0f9f1122afcef75b5c79c8d7002fd1f9bed406bc9ea00bfa1a6ac48419d04756b2f31303706b82d2090283aa7e721d3c0fe07e5a2c25e5faac27f8268a89256f4f2706e1fdd18069600e96c3527d6b89973ddadbf6ae16113baae7e6400e306636f309ee6737741a146baee99065f9a107e9fa39aa5807dc889ed36f889c7e14af548eecb5619330c7823bc8975d80c6f968d78a97d1cc6af277936b1fe8826b0d2e26a844fefda14242a3c0bb26344a489c272e715397f98c68e1a81d0efbb0f7770fc2a5cd736db0791220937d09ba37bb1846d82ca36876c3248786b73b6f1318a24fbd480294ee294ca948f124ad47851dcb7be0f0af23d64df7f2b6724783b6741f0c9e553bd02113141737e9c08d9ea984f9f535572175089cde141f0140b5bee9b51bff7e401a6e4d2c45e2ab7d151e9af38e0ababea88aa2f28f7b61b528693ae174076f308725c192a3d1c26308a91837984e01f02e98caf678b2df897ea9d8780613c444a77b9232166e14e001f3bef1c1e9fa7e4a6164c3d8f58bcb0395e1c993620ce5ab9fb26fbb8d4f68853ebc404eaeffb802ece1d3ffac326d422b459524c3dd8a2891c8c2f31cccac0c699ac302ea6bca02fc19c26160fa20e77bf51960d7bf9a6609050411c66ac8b645d69ddb10cb161d6729839ebee3b156ab8fb8bd9733e440225449ce3144b433310dd97f8df1338d253dd916eb1c260f4af488b13e7f22512803f970cb29feee72b0f7cf9309624f47f5b11a6a99b97095a3b93eec4bd5940876b7c5128588b982936792a7a77ae60ad42eb9800826e57a10465a3e753e50223cd68f579e3674c81775585fa7eb45834671606ba1a2d728866aba1eb889f4bdf3e579ad5f45c083e210f266424057e1afc9746dc8f1793691adfeffca505af019a7f0d44ea3966a955dfbde73dd1c58b579579fc404030caaf807444c3df1c2c8950dd288fe09d9a2df392c1d9cd7983345593bdb836824a3a8ec2a5c91c472c2936fcef4ccd6e095c54f159c75b89efc72d81e5d7d075121cd05e1b07492a4b2491f90ce9397875898fad46f06f94ce2d25cbfc8a5d565fbb220db1903769105730a964f4b63118e373b62567058198051499f4d32739cc532f4e6fa0f455ba976c1ea071999de6f5b49dad6d1aeb6f50d13b484b86b6e9b93aa4a9c9981a76e4322f12117e66857a96e7f4b9d8444a59610688aa6090cca63f47c8124fe659b8ca1376509e1a4d2b9fe080928e54000778d301ad9d52ce76b0296551c64a5950590ea48063703b49c99aa4e5f9b187ec60d711b039056f80c1b5f7b59faab48693d1c635c7e31c1707f20feccacac5f3cbb27ead42e297ee80e9f00e5cb0edaff72b964aa5043360561f63d75b5f3a342727df05d1bbecaf0f594f39f4d8b83f0948b91548f5bcc7fa27efe00461326b075412a0f4d275808b77adfd3d012060e8414b6115b7c1751b17013627fb7a2682da0f8a0f6c358643d01e47df8f7a760a3354c3c52df35d00d57bab2f40e93e465cc03ad097cbe587daefdefc7291b6ee9bef9b4ecf006d8fac4a6e7ec5493f6082728fcacbbefb61142fead50e662b3afb8c7de845b7117390b119ffedb8bb79263d4b7ee66626f16e9622ef6f9dcbcdb2c3233a7363d7f47e93cebf65119d5fd51a67187c4b20c7e3e415cac7150dd5aa9e71d7b226090ba9011a373fa0bcf04d071c39850e82d5d6f174a4f2e35c6b9c4100d0964d77ea66006723e7009952fc13fea009ef3a706994a241289e808496a55e71371e8a01f7e945f77986a879a4d319773256a268f8fc56e8a346c01c47ef460074291f23d3cbd4dbf3d01af2a1219ea2256dec99eaaea5359bbc28618f1af433f295a60228cb5e31237d2173e81d9d42023890bde9b539718870b66273779dc26a7ceea6f859027f6ef38fce8196d7defb7f1fe9f5b4da6a9f11833feba42c7ea62e724a5f230a713e5b008545f5137de74553f40257ce83e60a8c5da2347e45e464483016f3fe9d442cf56cc118773b17d8ab630e2459800e1123148ecd64ed1a32672144e1002006465cce7bee6e62632ea7466a91ebc4e26198ab9d58c1501e23af1fdd2c8dc66774540c1a13d4ee516cb803f4124b1276f1de84048f99c4936f36817eb74e93ca2c6942494443811c71e362d84b536f96cd3a58c780c850673cc6cea9fc1bfddf086056918e8cd3b60ba493640e17e0df406cda9f7cdfadcbe037af31a151a0b194303a18a88810430410dc92be31cf74b1273c603c1e69f828d3b5becaf7d3e1d8030c28d02b537385e0d69849292f1ec79d0298bd85b985618932329143cdd23fb44b3edc2cfd7459d28b106514be226e33374c161b82b85681e980fc9bed760d3cb16e1c3ea212465c6f6d32ba2ee4336e4bcea12a97da4fc48a451c57987f6ac8e039e6db391de7c2d3c1353232faa2e7a30291796b82f4ec8bffe8a54853323eaa8da18b83be262e05d37ceb78ea55fd9858f7408d917e7d633f5c5edb362f4a2fd59f80e5d70ebb03e6e937637774aeb5f81ed0f7aaacb26721e769f1580167aeb880f427f9ad8151b7ca0641ea2967595c5991f1af4105079d923c18b7c528f078e6ba0b0562af755c08e11fa4ed2fa3b2ffb9bac48df9d9d26f00038887609059b08de886c16246c62cedd4d1fd4be489fa6db8fdf765911927d5401c3d48a97253e5ed93aa2cb651793e1a5c81b5203304eca952693e0b5184d1d1d3852878ae9452a2e977a05e2badb5a3c437d3678095e2808209f615380340654fd378450dbb1b9621b28b16fe4dde9c6e4d29ce98f1bf073f3e9503d177ab26180aad98c9ce50e7de47a77ddda8bbe7a25f54d4c3b9dca9522d7e86adfcd27684d5ab694539cb17fdaa31a66d27544071bdd7ece984dd0ee327fd311da3f9876c1d3962b56ba81f2c6611766c251390b4c50325884f57e77699d37896c5578be2ec8ee34bfa169f293748472861d4afcd6cc9a020d7b7bb228620a8d6011f46859d8ec5aef6320d429eef71eac5a778fcebdb0e9f2893869ca5d45913e871837eb37101e46e45e28846946079535f732b60f3373c6e05c74dd3087c821a94c696c523b56127d0f4a9325effd14af9c7a5e575574fea96e72c0957ffd0fad2d13b703fc4c361705b0f7fe08a471dbd690204cb1c59748ef0aaadb3d2c475c07d160d326a6aad7d0b8b462073b203d6687515ceac1937b073ea824f81aa1fbb900fcdf0ead80e17db850a03f355d7d80829a101b5ac789b5e93fdea3c7439889f99c7ec976cbf5868b1fff462c4162756458e0800ccfcb33a1063df1514760feb11951a22e6a5fc897f90e6489c9041f72113312833ca0603f08c84fc6c36d062148fb121c8be066b77b951a9da78c03c5f9a22b8bbed8e5c16f69757542c4d59c073d27210818d6c7ef7fe829a128e22e10faaffe163c8127050996b319d228b6641f6e0c12155e00367ba3be238c0687b685856e385169b053174c7a7d462c6a36d75ab7c35621a36bb3a1a95247e5655e372d75848696c6ccd42419d3f6c84fd9ef0a36e63e543d9f1d91b03f086f294b5f8dc78bfe523ad50ed2c49af92d2065345cfded84f158c57a5d857588549b2b2f8575afc20ff16cc7c2e87bcaa56c8645e9c4fb043cc25f5626686f112cdedb077c5aaddfd60f576fd1ecde50470bcde669499f66231f6a794c8b5b3d5967a04677e863bcc7acfaa3cbf8ca5a6c98099fc77ae1fd8cd42561aadb87e3df7983fdfd6c620efd7b03cc968ae055069c151da82daec5753bb803e7d793d8665d0ce23c1351bbb15ef1f70fe880b585c56f626c2f3aedc3bc234152c42ba13f3029e8039ba96cb2c517c10cb4706c97992aa6feda6015801d3c9da34327f9948b4f8fd94f6a53be8544466ef4ad7d47e14c1fcacdabae84cbb90c5def9ed22f83f5309aed115e207beda002665c4c0beffaadde64ca4373bd55352f7604794e4fde1cb4e83929ff20bb6e36b2aa058b5a2b25a65e39d228bce6bc0445d344693c3ef78e0adc0c0ce8d4c8881b2b782b1eee97531743c1fad725730547312b891d5bc6861b586940077791a3cdd491574acc8ab7b95d0d5440186ef538d9d4284673bf24faed31cb95d7fb974399e76d356874f14b4e8f04816b1e198a3bd00c91b460e63011bb953b0302d7a4d9fc804527f2c20a479e57ec23afc7eadad481f2cc72e9816021c2421d9745a3705adc9869326c9ba1332273e2fadfc3467545ea56bbc6440f3a7ad226a6415c390697c38041f77040dea571d52df856cd8be0ec0c4b5901fe69562d35dcb971dad02be8838faad8f9825f7c6bc864c210f2d01da92f024e9c963916422d3cfd36cdbbae27e5920e8e0426e2c040cf05fe389918d237add4090b671c4ee5de94e7a71a54bb09de98e352b6da5fe18ed52369192bf1d28228b4ed15de7a27250dc5e011bb9edf70a84496d2b3a0299cf6f266440d878f21f0d8e36d2f7a16736f45dbf3fffedcee98449d781764c326da36e5f9092d215ae6d507ae9378a9fec7653d326d5a54a38cfabc7d16bf19a3f38f18f242168b80479af7213939fd48838ae97d0140b770e6187f8ec7be5e2c3334f422318194edc89277321c99a4de07f21e0802a888e497892db6c7b12f488040897bf065ecde39239ffad6c76f84cca58313c5972d9e74f2c15cc6b0fa2638cb84c7ff808bbb1b373c262c0da5a8398b2e80717e4c210a9645f9b3329eb19c6ba2ba402d93069355ff82d76fe61bda8bab661d9d4f9cd8b569a4287954440a32af17a9eb0b2439f08dff5fd7371026a7543dae1d6ad5da6185766ac1ca7a605b9d355f54aa1f2d42f34c16cb4021a94cf66e4561f7f7ec1429c0f5c341eb1981aa48e129549408947764c5c3a139d8703d2fe206c103eb7f2f46efa500e65678c1444270f1717238147c7ce72d923e821eab027875b49cd87185831e1b0252567fc79c49e6ae827c04411872cb9641fc2387054e9170bfc42eaf87a3fc7ce48d0f7d202beffcbe6ec776da06e6bb9aed0ac746ad005476f2aad01b7c3f5a1ffec8ffe6c3edf03cc08bbcf49c1c871e61fb751521ef8878b87ba4cdf659e44e772f5a91d067e060153ea8446c88eae62e52cbf95c9361156e0e9fa663f11d0e8852da95da75a77eb54be78f22ea8b0518769e7348e9f957742d24978a959d51766f0d2eb2798a8b5207068eeabcbd44f96950e7cdde837b4c6c7067857204ad37fcc312fb96021b5c67e9e2a18db6c7f9dfbdf0150604114a942e331cc6add881f99db768f5bdf03e410348814982928c75ef42bd25ac9fecdc766b0869794b76f117cf3bad8cd39c273c229a4cfeaac23f30918a5b50ad7a2086533ba099a8a68ed21bfcef4fdb583b20ee71e6da90584b7fc3963e664489385887be09ecf1a68e24d49ad43fc30ff3c6987ab4ac44ae919f6d4599b9cbbe688767e8ccb9a1f9011149d1d6b9a4a5a81168269fd7eb4cdf816035fedaf1775219dd0278cb8ef262256a32c7e96606dc6f5d92ab792c8f715df1dc4d1ce1501ebe00b3db6e2662c17f6b4047b03794977f598bd0ece3ae01ad7be989dd7125925580953ebaefe7eed4890eb6f414af767a2d3d7ec4308d82fc7a7be3361b2b877eca956f779ad6950183b52a29c3543c34cd4093a0498100738522ae7defb77554f6e18dd3278a2de44da96a2420a2a251af7c0e75e257e1bfae7acbe81b2f212e2e83978ebd4fe938a5b9d792c131d9094cb796b9530da6a34f3fc2cfece5751f36d736ae9928bb043e32f9608642f328cdd8bd0e319c55968bfaf58c33c4941da974697979996ab5c7a13c7740927d090fb42550c94a2d3593fab6f2910d1ce6bf03f1fc86d1e843ea8ac76fbaf16ca46282eb02d88503cecb3c4baf5c15983372c4f2ead164497292a068d87d86f1b07976cf23d138204fbce7d7763af32680916c71570620741fe4dc21930f01f6536a95a4a6de427aef4d45dd4db6770f23cd2c9ca0a1c46a2987de98213c8e4d0790f1c79ec5bdbb87dc8906a79a63d76ce792a338d445fa0df5b23761879336de05dc0f650bed18ee1b147679854276a0fb78266dc656bdbdf65a962e6c782a24763aec15f39b1dec124aeadd8fe3522d61022fa059a778267e9e4af209e9909f45f8035abd5276e0afe84bb0cf6ecbdceda301c16100f9f20bc4741dd4eea0e5a4109e9cbceab5a8e4bbf2940957fe744872b8b23b7c96082915d58858de92be9bbdb74ea3504f6846f1f56e750060d2dfd35a2f2f8b6e253efc950c17eeb7d6f2ce495f86052c390414a85fc24585a541af9d52b1e8e97d059987c50675828be4a5601a923043f212388227e66082999eca68df34ce714f6270b0d02827f08e306e759a83353ad38a66677591f7693b04977305e4eb51a7b26f9226729881454e2367dab41a4efeac23d05a1f3059846ec2ee1bd0cb47b74dc8bdad2f586496fce3cf9757c13fabd5711e0e5736c36b4692aad0338cecc8de34ff4d1d7ebd53edcfe9e20a4c75de81fc29a3760d2b1de7899aa928887592a2fec3e258d263f8c920f04fdb03971b003aced847a10f19c99d07a0d68bcf0b7ac748a9aa67af9f2689b196f30d75ec543f30adacfb8cec027c701807c71bd99159fcebccc5b44aa02203c184ad7fc382db03ecdedf2397d50f9346b2c8521b20b5d5cb20891de97bf838682024878e32f80286867225c7d1b1cec38184b45d891555fc8a55086e6a6e419f67994c6bdc4ce03f87e6817cea6b1fb45964a1f6d5d0256287bc9efb61af98021a8cdcd448eb8bf9075d996c2a7bdbb3042b09675b05a6720daf7e7e89592c0bd2872883e0712ea74bc0a49f8fd92c0290e60fbe0d5881c0565ea3a480943d3d79578fa2871f7472e298d46b6bbc69d52e701524e70d2d866181bd56034ec71cc1f64d4822558341e5047ba1e6f6c1055637eceb43fd83c769ec596e35e8bc4b920565cccbc7ce6fcbe00183d8fe466a4affe4d6f4330294841c72964034b58794a3749c65239f8d834b4bc2141efffac401f28062679a48034b1874a6cf1266fb02d41c802b60ce75e3a2e65147f407e4580f0f5cbf82e2742081b5bcb8e74f4cb12d674d23e6cb86702f9ccb96fc0b0fecc7b643c5e3409531eba7b3e6b6e10dea1df6d7e06a1a4e1e2497d32e020043c0878086536d3af3797bf4709fda21559b1731de9ab52ace297cb24d855cedd98b4f68494e3d66680f90c0302695d75b86238ba4960f5cea36fd2722d10ee57a638e5ee8ba28139493801bafc08a814ed7bc3bae4f98c31d9a39009b3cf7e80a5705dd03c91f6b6d915979f19d72900c1df3056e819b1cef5fb3aa1f609a543fee44f8418a4b6134911e7e1e65ec9e9e9070180912283a5b8cc700fe01cf9ab0f0db4f88429da0b79993bbefa14d43b4a3541fac504ca7dfb825c6f5b26553bb8bca23ec31f7aa5ef4dbfd38d64738f5782fd459e67439113db1e3f52023869b95f2abc214dc046fc9df0cb4ecab064086306b0c6cd64b43a2539e7365dcab297d5fe6f8542f674f0a2e1290e0d07f45288ff40c50ebdb1991d47c9ad9616a6f3973d2a94d281a910a18f871e0e81ddffbee85e7543b7cea0b13c80ed33d04b1ec60fe0a2da2c6aa696da49ff666b82c723dc91a032e1cabdb563431fa87388ac50a2c76203568bf365b56feddfe5ce5b6fa59dee95fbe420144eb7da5063eae2e93316ba86ce0cb74ac0e957acac9f27dad974334e7377b80ff89db251ba5986bff74c92f58779648dd7332e6cc280d12908c7cd915a4fd99453db689c7a8b25e8dc5ea32151b72708998fc5cb4e7e04ecce24237d6cc6fa86f9ab2d766e05a3dc7c72bcc70ad97010dd2679e356e2d04fee3346c489e2381667765623ab3f1008e3caaa07cf0421fb206da73923e4f4c48309246b550cff84dd89f3f16d0417c494ea14c212dc62a461459221631884a0ae971ff2cbfafc9e4587f473751779c35b3a93de0d1dbee5e7b2d5ad266b6fc5b008d3e8959cb9535d4378da210730f9c1cc544ade4e187e6329f301b22d700d00e12bfbae5028ff4280304942d806c6da03c33fe133b8cbf2ecc58232975c08ba9cce3eb51b59187ff96ca8443177985e3e2e398c058fbebf81920f8c49021fa1837c8d6154bbe52d7285deb3905c25ca088b10cfdb4494f8269393c8bc366297bc180395dc9b9454b5c66ec889fd65a8c0faf607096a0affd5d1a48e4a7f50158a0573a427b6074796b2fae7d829098b3ba2e8798ecda7794bc8d8f6b29ca50ec0530366db689eff41b5ca111c547bab9d6b1c97e5d0fa182ba5ec159e037e49ced30f6108d93dc6a6a7c71b896c0f43a7d3d0b9a65ea851eac7e1f889fd978e5ef148b90ada03152140eeab8bc763f76e23b06eda4c72c17090bb92e1af33464e6e7917cdf8ca3634fb6b6a7b4e082d0197e84a84f54435be4935f5b5dd49a82137b714220537daeb67eb79d8d60b5772aac3bdcdce5a9d5eef1ebe4dbcc02584ed1989785d110cb7aa8acc5c264cf535a6c4f112e64511878c31e4fb61f01b1719e6603d50a0b0f3b1aff563103580307b9e69b30ee00d57d42f4574da26a05f1002c8963e46ad3d47239e03e4842b87f1b938e5519b11478204cb670e905f86fa846572b8c8df5de907769898ec1bb466a9a7cfe89d6c549a5d504c9530f9f7381804c897ca29a391d0dbcaf4129834a6444db3aea4398bbb11032fae8dac41c64e1ea60be375334fea40b628e7214ce23a5b62cf943cc8c178264e46b435f935632c8c7fffdfd9a9445ff73a7e47450943a8ab65d65e09bdf5422f807f383efe8f336e7c13e0f7352c7c5db47531ea3d3e444d0e3e7544063d5d8c2113a1e356c4fa86307d31a5e8e6c678739fdc77e5b72bd66ec59cdcd017b752bfaa35c20e2b59cda9b9a11bb9a9bb6d7785024b2c727e73fb8fd958e497f784a52e9ac4527620097e3aeaad38c8ff58fd8f658e5596eeb6da242834894b9beb2e6473960ab3cd3b30eb29bfd59561acf1e1d5470f6265b9da9293bffb0876734a890e0fec06944ae1031c0bd13bb2706d44a30f90b5e19335aaa2e5b7142255740cc05ad27763f561f6a841b6ca0dab6f37e97cfe39833731487e58f751c17b7cd10233e2a966931a2f0f0cfcc3bc4250358798fa9fb3e95772b2f4077e1808232546016ba98c383751330ac996f023d3e9e3ce796dc70fe4cc43f12461c4c386ef013d972493b26f283fecf7cd7f0a16032075b51a6b2b8b01b49232a2ebfb4a758fe6221c870551d3f121975fcc152db91397d3a8467d8f98d73c963534e710036ff17c5b7b27f2a6220757ab48c8a9ce703bb2778af20e0bd76f3ad3d9624e9525043a6b74690ae7b6b0e32b13588fcf5bf8284cae75bdd90b70e2d05b9893fc2e4cbeb08ba94e6c42889ea03b2ebd8231753d39f536d1454060694d446030041ef1b366efdf1909c63a429fee6dde1e54a41912d4d21d2b63e295e156aa0399695ff69fedea89232c131b198f63a7455fdb299b28f9be026043b8e07996ef5b87947a95bf391cf00f2d924738ac0615f8b1f823b7e064ca3c13b3a02ffaaa84c9273db4f6970b97169a7454180a73d9c84bc02ffa1d9d19abc0cf3566166f368defc28bc6951181135e7d4df25f32a208720618578a77794b23d5b8456cfd9f8b0e572231e14908b987678679b93d6d313be5af772f6944efb8d2291fab9ed0c8f8b65f234f54c488cc69395a3888aa63ae4726473773075c07ca9f0a5f132f0ac9c1f19dd97127d8bb9c1596d541b8745dcd431404906c2db90c1946065aea7a0c56d300b77772dc63015caece6611edc68978c07d8a28113a01b9b4f181d569a50081d181ae9e956cf5f7ceb2f5da73adfb1b7148af32fcf971f6bc00af197f52b381f1ff7e855c969eb4db4d3cd4229612f3ba0f7c3a9245691acdcadbd4713c140df7914324ec4e1170c46fac48044c0d0af9218fdfa3990a475acf0d608a51554789b2803480ed307c450524cdeaaa2b82d65e8037928d0414df212ab6ec8fe025a30fabcda2c800383d08693729d2b56b0ee91543d8b2b9442cb70397666c264ea39fb3f9929bc3d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
